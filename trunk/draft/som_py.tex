{{\def\dash{\raise2.1pt\hbox{\rule{5pt}{0.3pt}}\hspace{1pt}}\begin{tabbing}
{\texttt{\string"\string"}}{\texttt{\string"}}\\
{\texttt{Python\hspace{6pt}Self\dash{}Organizing\hspace{6pt}Maps\hspace{6pt}with\hspace{6pt}Spherical\hspace{6pt}Lattice}}\\
{\texttt{\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}}}\\
{\texttt{AUTHOR(S):\hspace{36pt}Charles\hspace{6pt}R.\hspace{6pt}Schmidt\hspace{6pt}cschmidt@rohan.sdsu.edu}}\\
{\texttt{\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}}}\\
{\texttt{Copyright\hspace{6pt}(c)\hspace{6pt}2006\dash{}2008\hspace{12pt}Charles\hspace{6pt}R.\hspace{6pt}Schmidt}}\\
{\texttt{======================================================================}}\\
{\texttt{This\hspace{6pt}source\hspace{6pt}code\hspace{6pt}is\hspace{6pt}probably\hspace{6pt}licensed\hspace{6pt}under\hspace{6pt}the\hspace{6pt}GNU\hspace{6pt}General\hspace{6pt}Public\hspace{6pt}License,}}\\
{\texttt{Version\hspace{6pt}2,\hspace{6pt}you\hspace{6pt}should\hspace{6pt}check.}}\\
{\texttt{======================================================================}}\\
{\texttt{\string"}}{\texttt{\string"\string"}}\\
{\textbf{import}}\hspace{6pt}random,math,time,sys,os\\
{\textbf{from}}\hspace{6pt}numpy\hspace{6pt}{\textbf{import}}\hspace{6pt}array,empty,take,put,zeros\\
{\textbf{import}}\hspace{6pt}numpy\hspace{6pt}as\hspace{6pt}N\\
{\textbf{from}}\hspace{6pt}math\hspace{6pt}{\textbf{import}}\hspace{6pt}acos,sqrt,pi,degrees,sin,cos,asin\\
{\textbf{import}}\hspace{6pt}networkx\hspace{6pt}as\hspace{6pt}NX\\
{\it{\#import\hspace{6pt}pylab}}\\
{\textbf{import}}\hspace{6pt}pickle\\
{\textbf{from}}\hspace{6pt}utils\hspace{6pt}{\textbf{import}}\hspace{6pt}$\ast$\\
\\
{\textbf{class}}\hspace{6pt}som:\\
\hspace{24pt}{\texttt{{'}{'}}}{\texttt{{'}\hspace{6pt}Base\hspace{6pt}class\hspace{6pt}for\hspace{6pt}the\hspace{6pt}Self\dash{}Organizing\hspace{6pt}Map,}}\\
{\texttt{\hspace{48pt}Each\hspace{6pt}topology\hspace{6pt}will\hspace{6pt}inherit\hspace{6pt}from\hspace{6pt}this\hspace{6pt}class.}}\\
{\texttt{\hspace{48pt}A\hspace{6pt}template\hspace{6pt}is\hspace{6pt}provied\hspace{6pt}in\hspace{6pt}{'}}}Topology{\texttt{{'}}}\\
{\texttt{\hspace{24pt}{'}}}{\texttt{{'}{'}}}\\
\hspace{24pt}{\textbf{def}}\hspace{6pt}\_\_init\_\_(self):\\
\hspace{48pt}self.Dims\hspace{6pt}=\hspace{6pt}0\\
\hspace{48pt}self.X\hspace{6pt}=\hspace{6pt}0\\
\hspace{48pt}self.Y\hspace{6pt}=\hspace{6pt}0\\
\hspace{48pt}self.Size\hspace{6pt}=\hspace{6pt}0\\
\hspace{48pt}self.Type\hspace{6pt}=\hspace{6pt}{\texttt{{'}none{'}}}\\
\hspace{48pt}self.tSteps\hspace{6pt}=\hspace{6pt}0\\
\hspace{48pt}self.maxN\hspace{6pt}=\hspace{6pt}0\\
\hspace{48pt}self.alpha0\hspace{6pt}=\hspace{6pt}0\\
\hspace{48pt}self.nodes\hspace{6pt}=\hspace{6pt}{[}{]}\\
\hspace{48pt}self.daMap\hspace{6pt}=\hspace{6pt}\{\}\\
\\
\hspace{24pt}{\textbf{def}}\hspace{6pt}load(self,path={\texttt{{'}{'}}},name=None):\\
\hspace{48pt}{\textbf{if}}\hspace{6pt}{\textbf{not}}\hspace{6pt}name:\\
\hspace{72pt}name\hspace{6pt}=\hspace{6pt}{\texttt{{'}\%ds\_\%dd\_\%dr\_\%fa{'}}}\%(self.Size,self.Dims,self.tSteps,self.alpha0)\\
\hspace{48pt}codname\hspace{6pt}=\hspace{6pt}path+name+{\texttt{{'}.cod{'}}}\\
\hspace{48pt}mapname\hspace{6pt}=\hspace{6pt}path+name+{\texttt{{'}.map{'}}}\\
\hspace{48pt}{\textbf{if}}\hspace{6pt}os.path.exists(mapname):\\
\hspace{72pt}{\textbf{try:}}\\
\hspace{96pt}f\hspace{6pt}=\hspace{6pt}open(mapname,{\texttt{{'}r{'}}})\\
\hspace{96pt}self.daMap\hspace{6pt}=\hspace{6pt}pickle.load(f)\\
\hspace{96pt}f.close()\\
\hspace{72pt}{\textbf{except:}}\\
\hspace{96pt}self.daMap\hspace{6pt}=\hspace{6pt}\{\}\\
\hspace{48pt}dataf\hspace{6pt}=\hspace{6pt}open(codname,{\texttt{{'}r{'}}})\\
\hspace{48pt}header\hspace{6pt}=\hspace{6pt}dataf.next()\\
\hspace{48pt}Dims,Type,x,y,nType=\hspace{6pt}header.split()\\
\hspace{48pt}self.Dims\hspace{6pt}=\hspace{6pt}int(Dims)\\
\hspace{48pt}self.Type\hspace{6pt}=\hspace{6pt}Type\\
\hspace{48pt}self.X,\hspace{6pt}self.Y\hspace{6pt}=\hspace{6pt}int(x),int(y)\\
\hspace{48pt}self.Size\hspace{6pt}=\hspace{6pt}self.X$\ast$self.Y\\
\hspace{48pt}self.nodes\hspace{6pt}=\hspace{6pt}array({[}{[}0.0\hspace{6pt}{\textbf{for}}\hspace{6pt}i\hspace{6pt}{\textbf{in}}\hspace{6pt}xrange(self.Dims){]}\hspace{6pt}{\textbf{for}}\hspace{6pt}j\hspace{6pt}{\textbf{in}}\hspace{6pt}xrange(self.Size){]})\\
\hspace{48pt}{\textbf{for}}\hspace{6pt}i\hspace{6pt}{\textbf{in}}\hspace{6pt}xrange(self.Size):\\
\hspace{72pt}data\hspace{6pt}=\hspace{6pt}dataf.next()\\
\hspace{72pt}data\hspace{6pt}=\hspace{6pt}data.split()\\
\hspace{72pt}data\hspace{6pt}=\hspace{6pt}map(float,data)\\
\hspace{72pt}self.nodes{[}i{]}\hspace{6pt}=\hspace{6pt}data\\
\hspace{48pt}self.diffs\hspace{6pt}=\hspace{6pt}array({[}{[}0.0\hspace{6pt}{\textbf{for}}\hspace{6pt}i\hspace{6pt}{\textbf{in}}\hspace{6pt}xrange(self.Dims){]}\hspace{6pt}{\textbf{for}}\hspace{6pt}j\hspace{6pt}{\textbf{in}}\hspace{6pt}xrange(self.Size){]})\\
\\
\hspace{24pt}{\textbf{def}}\hspace{6pt}save(self,path={\texttt{{'}{'}}},name=None):\\
\hspace{48pt}{\textbf{if}}\hspace{6pt}self.X\hspace{6pt}==\hspace{6pt}0\hspace{6pt}{\textbf{or}}\hspace{6pt}self.Y\hspace{6pt}==\hspace{6pt}0:\\
\hspace{72pt}self.X\hspace{6pt}=\hspace{6pt}self.Size\\
\hspace{72pt}self.Y\hspace{6pt}=\hspace{6pt}1\\
\hspace{48pt}{\textbf{if}}\hspace{6pt}{\textbf{not}}\hspace{6pt}name:\\
\hspace{72pt}name\hspace{6pt}=\hspace{6pt}{\texttt{{'}\%ds\_\%dd\_\%dr\_\%fa{'}}}\%(self.Size,self.Dims,self.tSteps,self.alpha0)\\
\hspace{48pt}codname\hspace{6pt}=\hspace{6pt}path+name+{\texttt{{'}.cod{'}}}\\
\hspace{48pt}cxdname\hspace{6pt}=\hspace{6pt}path+name+{\texttt{{'}.cxd{'}}}\\
\hspace{48pt}mapname\hspace{6pt}=\hspace{6pt}path+name+{\texttt{{'}.map{'}}}\\
\hspace{48pt}{\textbf{if}}\hspace{6pt}self.daMap:\\
\hspace{72pt}mapfile\hspace{6pt}=\hspace{6pt}open(mapname,{\texttt{{'}w{'}}})\\
\hspace{72pt}pickle.dump(self.daMap,mapfile)\\
\hspace{72pt}mapfile.close()\\
\hspace{48pt}outf\hspace{6pt}=\hspace{6pt}open(codname,{\texttt{{'}w{'}}})\\
\hspace{48pt}outx\hspace{6pt}=\hspace{6pt}open(cxdname,{\texttt{{'}w{'}}})\\
\hspace{48pt}outf.write({\texttt{\string"\%d\hspace{6pt}\%s\hspace{6pt}\%d\hspace{6pt}\%d\hspace{6pt}gaussian$\backslash$n\string"}}\%(self.Dims,self.Type,self.X,self.Y))\\
\hspace{48pt}outx.write({\texttt{\string"\%d\hspace{6pt}\%s\hspace{6pt}\%d\hspace{6pt}\%d\hspace{6pt}gaussian\hspace{6pt}CUM\hspace{6pt}DIFF\hspace{6pt}FILE$\backslash$n\string"}}\%(self.Dims,self.Type,self.X,self.Y))\\
\hspace{48pt}{\textbf{for}}\hspace{6pt}i\hspace{6pt}{\textbf{in}}\hspace{6pt}xrange(self.Size):\\
\hspace{72pt}outf.write({\texttt{{'}\hspace{6pt}{'}}}.join(str(self.nodes{[}i{]}.tolist()){[}1:\dash{}1{]}.split({\texttt{{'},\hspace{6pt}{'}}}))+{\texttt{{'}$\backslash$n{'}}})\\
\hspace{72pt}outx.write({\texttt{{'}\hspace{6pt}{'}}}.join(str(self.diffs{[}i{]}.tolist()){[}1:\dash{}1{]}.split({\texttt{{'},\hspace{6pt}{'}}}))+{\texttt{{'}$\backslash$n{'}}})\\
\hspace{48pt}outf.close()\\
\hspace{48pt}outx.close()\\
\\
\hspace{24pt}{\textbf{def}}\hspace{6pt}randInit(self):\\
\hspace{48pt}self.nodes\hspace{6pt}=\hspace{6pt}array({[}{[}random.random()\hspace{6pt}{\textbf{for}}\hspace{6pt}j\hspace{6pt}{\textbf{in}}\hspace{6pt}xrange(self.Dims){]}\hspace{6pt}{\textbf{for}}\hspace{6pt}i\hspace{6pt}{\textbf{in}}\hspace{6pt}xrange(self.Size){]})\\
\hspace{48pt}{\it{\#\hspace{6pt}This\hspace{6pt}diffs\hspace{6pt}will\hspace{6pt}define\hspace{6pt}your\hspace{6pt}walls!}}\\
\hspace{48pt}self.diffs\hspace{6pt}=\hspace{6pt}array({[}{[}0.0\hspace{6pt}{\textbf{for}}\hspace{6pt}i\hspace{6pt}{\textbf{in}}\hspace{6pt}xrange(self.Dims){]}\hspace{6pt}{\textbf{for}}\hspace{6pt}j\hspace{6pt}{\textbf{in}}\hspace{6pt}xrange(self.Size){]})\\
\\
\hspace{24pt}{\textbf{def}}\hspace{6pt}findBMU(self,ind,v,ReturnDist\hspace{6pt}=\hspace{6pt}False):\\
\hspace{48pt}d\hspace{6pt}=\hspace{6pt}((self.nodes\dash{}v)$\ast$$\ast$2).sum(1)\\
\hspace{48pt}minI\hspace{6pt}=\hspace{6pt}d.argmin()\\
\hspace{48pt}{\textbf{if}}\hspace{6pt}ReturnDist:\\
\hspace{72pt}minD\hspace{6pt}=\hspace{6pt}d{[}minI{]}\\
\hspace{72pt}{\textbf{return}}\hspace{6pt}minI,minD\\
\hspace{48pt}{\textbf{else:}}\\
\hspace{72pt}{\textbf{return}}\hspace{6pt}minI\\
\\
\hspace{24pt}{\textbf{def}}\hspace{6pt}diff(self,nodeid,ind,v):\\
\hspace{48pt}node\hspace{6pt}=\hspace{6pt}take(self.nodes{[}nodeid{]},ind)\\
\hspace{48pt}{\textbf{return}}\hspace{6pt}sum((node\dash{}v)$\ast$$\ast$2)\\
\\
\hspace{24pt}{\textbf{def}}\hspace{6pt}alpha(self,t):\\
\hspace{48pt}r\hspace{6pt}=\hspace{6pt}self.alpha0\hspace{6pt}$\ast$\hspace{6pt}(1\hspace{6pt}\dash{}\hspace{6pt}(t/float(self.tSteps)))\\
\hspace{48pt}{\textbf{if}}\hspace{6pt}r\hspace{6pt}$<$\hspace{6pt}0:\hspace{6pt}r\hspace{6pt}=\hspace{6pt}0\\
\hspace{48pt}{\textbf{return}}\hspace{6pt}r\\
\hspace{24pt}{\textbf{def}}\hspace{6pt}hci(self,\hspace{6pt}t,\hspace{6pt}dist):\\
\hspace{48pt}sigma\hspace{6pt}=\hspace{6pt}self.kernalWidth(t)\\
\hspace{48pt}a\hspace{6pt}=\hspace{6pt}self.alpha(t)\\
\hspace{48pt}top\hspace{6pt}=\hspace{6pt}dist$\ast$$\ast$2\\
\hspace{48pt}bottom\hspace{6pt}=\hspace{6pt}(2$\ast$(float(sigma)$\ast$$\ast$2))\\
\hspace{48pt}{\textbf{return}}\hspace{6pt}a\hspace{6pt}$\ast$\hspace{6pt}math.exp(\dash{}top/bottom)\\
\hspace{24pt}{\textbf{def}}\hspace{6pt}kernalWidth(self,t):\\
\hspace{48pt}{\texttt{\string"\string"}}{\texttt{\string"Returns\hspace{6pt}the\hspace{6pt}number\hspace{6pt}of\hspace{6pt}neurons\hspace{6pt}to\hspace{6pt}include\hspace{6pt}at\hspace{6pt}time\hspace{6pt}t}}\\
{\texttt{\hspace{66pt}this\hspace{6pt}should\hspace{6pt}probably\hspace{6pt}return\hspace{6pt}the\hspace{6pt}current\hspace{6pt}order\hspace{6pt}instead,}}\\
{\texttt{\hspace{66pt}which\hspace{6pt}means\hspace{6pt}it\hspace{6pt}should\hspace{6pt}be\hspace{6pt}moved\hspace{6pt}to\hspace{6pt}Topology.\string"}}{\texttt{\string"\string"}}\\
\hspace{48pt}r\hspace{6pt}=\hspace{6pt}round((self.Size$\ast$self.maxN)\hspace{6pt}$\ast$\hspace{6pt}(1\hspace{6pt}\dash{}\hspace{6pt}(t/float(self.tSteps))))\\
\hspace{48pt}r\hspace{6pt}=\hspace{6pt}int(r)\\
\hspace{48pt}{\textbf{if}}\hspace{6pt}r\hspace{6pt}==\hspace{6pt}0:\hspace{6pt}r\hspace{6pt}=\hspace{6pt}1\\
\hspace{48pt}{\textbf{return}}\hspace{6pt}r\\
\\
\hspace{24pt}{\textbf{def}}\hspace{6pt}merge(self,t,ind,v):\\
\hspace{48pt}bmu\hspace{6pt}=\hspace{6pt}self.findBMU(ind,v)\\
\hspace{48pt}sigma\hspace{6pt}=\hspace{6pt}self.kernalWidth(t)\\
\hspace{48pt}results\hspace{6pt}=\hspace{6pt}self.neighborhood(\hspace{6pt}bmu\hspace{6pt},\hspace{6pt}sigma\hspace{6pt})\\
\hspace{48pt}alteredNodes\hspace{6pt}=\hspace{6pt}{[}(results{[}i{]},self.hci(t,self.odist(i)))\hspace{6pt}{\textbf{for}}\hspace{6pt}i\hspace{6pt}{\textbf{in}}\hspace{6pt}xrange(len(results)){]}\\
\hspace{48pt}{\textbf{for}}\hspace{6pt}nodeID,hc\hspace{6pt}{\textbf{in}}\hspace{6pt}alteredNodes:\\
\hspace{72pt}{\textbf{if}}\hspace{6pt}len(ind)\hspace{6pt}==\hspace{6pt}self.Dims:\\
\hspace{96pt}part\hspace{6pt}=\hspace{6pt}self.nodes{[}nodeID{]}\\
\hspace{96pt}delta\hspace{6pt}=\hspace{6pt}hc$\ast$(v\dash{}part)\\
\hspace{96pt}self.nodes{[}nodeID{]}\hspace{6pt}=\hspace{6pt}part+delta\\
\hspace{96pt}self.diffs{[}nodeID{]}\hspace{6pt}+=\hspace{6pt}abs(delta)\\
\hspace{72pt}{\textbf{else:}}\\
\hspace{96pt}part\hspace{6pt}=\hspace{6pt}take(self.nodes{[}nodeID{]},ind)\\
\hspace{96pt}delta\hspace{6pt}=\hspace{6pt}hc$\ast$(v\dash{}part)\\
\hspace{96pt}put(self.nodes{[}nodeID{]},ind,part+delta)\\
\hspace{96pt}self.diffs{[}nodeID{]}\hspace{6pt}+=\hspace{6pt}abs(delta)\\
\\
\hspace{24pt}{\textbf{def}}\hspace{6pt}run(self,obsf):\\
\hspace{48pt}self.neighborhoodCache\hspace{6pt}=\hspace{6pt}\{\}\\
\hspace{48pt}{\textbf{print}}\hspace{6pt}{\texttt{\string"\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\string"}}\\
\hspace{48pt}{\textbf{print}}\hspace{6pt}{\texttt{\string"\#\#\#\hspace{48pt}Configuration\hspace{54pt}\#\#\#\string"}}\\
\hspace{48pt}{\textbf{print}}\hspace{6pt}{\texttt{\string"\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\string"}}\\
\hspace{48pt}{\textbf{print}}\hspace{6pt}{\texttt{\string"\hspace{12pt}N\hspace{6pt}=\hspace{6pt}\%d,\hspace{6pt}maxN\hspace{6pt}=\hspace{6pt}\%f\string"}}\%(self.Size,self.maxN)\\
\hspace{48pt}{\textbf{print}}\hspace{6pt}{\texttt{\string"\hspace{12pt}Total\hspace{6pt}runs:\hspace{6pt}\%d\string"}}\%self.tSteps\\
\hspace{48pt}{\textbf{print}}\hspace{6pt}{\texttt{\string"\hspace{12pt}initial\hspace{6pt}learning\hspace{6pt}rate\hspace{6pt}=\hspace{6pt}\%f\string"}}\%self.alpha0\\
\hspace{48pt}{\textbf{print}}\hspace{6pt}{\texttt{\string"\hspace{12pt}Obs\hspace{6pt}File:\%s\string"}}\%obsf.filename\\
\hspace{48pt}{\textbf{print}}\hspace{6pt}{\texttt{\string"\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\string"}}\\
\hspace{48pt}{\textbf{print}}\hspace{6pt}{\texttt{\string"\#\#\#\hspace{60pt}End\hspace{6pt}Config\hspace{60pt}\#\#\#\string"}}\\
\hspace{48pt}{\textbf{print}}\hspace{6pt}{\texttt{\string"\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\string"}}\\
\hspace{48pt}{\textbf{print}}\hspace{6pt}{\texttt{\string"\string"}}\\
\hspace{48pt}{\textbf{print}}\hspace{6pt}{\texttt{\string"Running...\string"}}\\
\hspace{48pt}t1\hspace{6pt}=\hspace{6pt}time.time()\\
\hspace{48pt}{\it{\#s\hspace{6pt}=\hspace{6pt}{'}{'}}}\\
\hspace{48pt}T\hspace{6pt}=\hspace{6pt}self.tSteps\\
\hspace{48pt}{\textbf{for}}\hspace{6pt}t\hspace{6pt}{\textbf{in}}\hspace{6pt}xrange(self.tSteps):\\
\hspace{72pt}id,ind,v\hspace{6pt}=\hspace{6pt}obsf.stream()\\
\hspace{72pt}self.merge(t,ind,v)\\
\hspace{72pt}{\it{\#\#\#\hspace{6pt}}}\\
\hspace{72pt}{\it{\#if\hspace{6pt}t\%100\hspace{6pt}==\hspace{6pt}0:}}\\
\hspace{72pt}{\it{\#\hspace{24pt}if\hspace{6pt}len(s)\hspace{6pt}$>$\hspace{6pt}60:}}\\
\hspace{72pt}{\it{\#\hspace{48pt}print\hspace{6pt}{'}$\backslash$r{'}+s}}\\
\hspace{72pt}{\it{\#\hspace{48pt}s\hspace{6pt}=\hspace{6pt}{'}{'}}}\\
\hspace{72pt}{\it{\#\hspace{24pt}s\hspace{6pt}+=\hspace{6pt}{'}\%d...{'}\%t}}\\
\hspace{72pt}{\it{\#sys.stdout.write(\string"$\backslash$r\%s\%d\string"\%(s,t))}}\\
\hspace{72pt}sys.stdout.write({\texttt{\string"$\backslash$r\%.2f\%\%\string"}}\%(100$\ast$float(t)/T))\\
\hspace{72pt}sys.stdout.flush()\\
\hspace{48pt}{\textbf{print}}\hspace{6pt}{\texttt{\string"$\backslash$nRun\hspace{6pt}compleated\hspace{6pt}in\hspace{6pt}\%f\hspace{6pt}seconds\string"}}\%(time.time()\dash{}t1)\\
\\
\hspace{24pt}{\textbf{def}}\hspace{6pt}map(self,obsf):\\
\hspace{48pt}{\texttt{\string"\string"}}{\texttt{\string"\hspace{6pt}This\hspace{6pt}function\hspace{6pt}needs\hspace{6pt}an\hspace{6pt}overhall\hspace{6pt}\#5\string"}}{\texttt{\string"\string"}}\\
\hspace{48pt}qerror\hspace{6pt}=\hspace{6pt}0\\
\hspace{48pt}counter\hspace{6pt}=\hspace{6pt}0\hspace{6pt}\\
\hspace{48pt}daMap\hspace{6pt}=\hspace{6pt}\{\}\hspace{6pt}{\it{\#\hspace{6pt}keys\hspace{6pt}are\hspace{6pt}node\hspace{6pt}ID{'}s,\hspace{6pt}values\hspace{6pt}are\hspace{6pt}lists\hspace{6pt}of\hspace{6pt}observation\hspace{6pt}ID{'}s.}}\\
\hspace{48pt}{\textbf{for}}\hspace{6pt}id,dimIds,obs\hspace{6pt}{\textbf{in}}\hspace{6pt}obsf:\\
\hspace{72pt}bm,err\hspace{6pt}=\hspace{6pt}self.findBMU(dimIds,obs,ReturnDist=True)\\
\hspace{72pt}qerror\hspace{6pt}+=\hspace{6pt}err\\
\hspace{72pt}{\textbf{if}}\hspace{6pt}{\textbf{not}}\hspace{6pt}bm\hspace{6pt}{\textbf{in}}\hspace{6pt}daMap:\\
\hspace{96pt}daMap{[}bm{]}\hspace{6pt}=\hspace{6pt}{[}{]}\\
\hspace{72pt}daMap{[}bm{]}.append(id)\\
\hspace{72pt}sys.stdout.write({\texttt{\string".\%d,\%f.$\backslash$r\string"}}\%(counter,err))\\
\hspace{72pt}sys.stdout.flush()\\
\hspace{72pt}counter\hspace{6pt}+=\hspace{6pt}1\\
\hspace{48pt}{\textbf{print}}\hspace{6pt}{\texttt{\string"\string"}}\\
\hspace{48pt}qerror\hspace{6pt}=\hspace{6pt}qerror/counter\\
\hspace{48pt}self.daMap\hspace{6pt}=\hspace{6pt}daMap\\
\hspace{48pt}{\textbf{return}}\hspace{6pt}qerror\\
\\
{\textbf{class}}\hspace{6pt}Topology(som):\\
\hspace{24pt}{\texttt{\string"\string"}}{\texttt{\string"\hspace{6pt}Template\hspace{6pt}class\hspace{6pt}for\hspace{6pt}topology\hspace{6pt}Copy\hspace{6pt}this\hspace{6pt}class\hspace{6pt}to\hspace{6pt}create\hspace{6pt}a\hspace{6pt}new\hspace{6pt}topology\hspace{6pt}for\hspace{6pt}som\string"}}{\texttt{\string"\string"}}\\
\hspace{24pt}{\textbf{def}}\hspace{6pt}\_\_init\_\_(self):\\
\hspace{48pt}som.\_\_init\_\_(self)\\
\hspace{24pt}{\textbf{def}}\hspace{6pt}save(self,path,name):\\
\hspace{48pt}som.save(self,path,name)\\
\hspace{24pt}{\textbf{def}}\hspace{6pt}load(self,path,name):\\
\hspace{48pt}som.load(self,path,name)\\
\hspace{24pt}{\textbf{def}}\hspace{6pt}randInit(self):\\
\hspace{48pt}som.randInit(self)\\
\hspace{24pt}{\textbf{def}}\hspace{6pt}kernalWidth(self,t):\\
\hspace{48pt}{\texttt{\string"\string"}}{\texttt{\string"}}\\
{\texttt{\hspace{48pt}You\hspace{6pt}should\hspace{6pt}overwrite\hspace{6pt}this,\hspace{6pt}see\hspace{6pt}note\hspace{6pt}above...}}\\
{\texttt{\hspace{48pt}kernalWidth\hspace{6pt}returns\hspace{6pt}the\hspace{6pt}width\hspace{6pt}of\hspace{6pt}the\hspace{6pt}neighborhood\hspace{6pt}in\hspace{6pt}terms\hspace{6pt}of\hspace{6pt}order}}\\
{\texttt{\hspace{48pt}\string"}}{\texttt{\string"\string"}}\\
\hspace{48pt}{\textbf{pass}}\\
\hspace{24pt}{\textbf{def}}\hspace{6pt}odist(n):\\
\hspace{48pt}{\texttt{\string"\string"}}{\texttt{\string"}}\\
{\texttt{\hspace{48pt}n\hspace{6pt}is\hspace{6pt}the\hspace{6pt}nth\hspace{6pt}neuron\hspace{6pt}in\hspace{6pt}the\hspace{6pt}in\hspace{6pt}neighborhood,\hspace{6pt}return{'}s\hspace{6pt}order}}\\
{\texttt{\hspace{48pt}example\hspace{6pt}the\hspace{6pt}3rd\hspace{6pt}neuron\hspace{6pt}in\hspace{6pt}the\hspace{6pt}set\hspace{6pt}is\hspace{6pt}1\hspace{6pt}order\hspace{6pt}from\hspace{6pt}the\hspace{6pt}0th.}}\\
{\texttt{\hspace{48pt}\string"}}{\texttt{\string"\string"}}\\
\hspace{48pt}{\textbf{pass}}\\
\hspace{24pt}{\textbf{def}}\hspace{6pt}neighborhood(self,bmu,kernalWidth):\\
\hspace{48pt}{\texttt{\string"\string"}}{\texttt{\string"}}\\
{\texttt{\hspace{48pt}This\hspace{6pt}function\hspace{6pt}must\hspace{6pt}return\hspace{6pt}the\hspace{6pt}ID{'}s\hspace{6pt}of\hspace{6pt}the\hspace{6pt}nodes\hspace{6pt}inside\hspace{6pt}the\hspace{6pt}neighborhood,\hspace{6pt}}}\\
{\texttt{\hspace{48pt}NumNeighbors\hspace{6pt}is\hspace{6pt}defined\hspace{6pt}by\hspace{6pt}kernalWidth\hspace{6pt}and\hspace{6pt}is\hspace{6pt}expressed\hspace{6pt}as\hspace{6pt}an\hspace{6pt}order.}}\\
{\texttt{\hspace{48pt}bmu\hspace{6pt}is\hspace{6pt}the\hspace{6pt}id\hspace{6pt}of\hspace{6pt}the\hspace{6pt}best\hspace{6pt}match,\hspace{6pt}or\hspace{6pt}neighborhood\hspace{6pt}center.}}\\
{\texttt{\hspace{48pt}\string"}}{\texttt{\string"\string"}}\\
\hspace{48pt}{\textbf{pass}}\\
\hspace{24pt}\\
{\textbf{class}}\hspace{6pt}GraphTopology(som):\\
\hspace{24pt}{\texttt{\string"\string"}}{\texttt{\string"\hspace{6pt}Template\hspace{6pt}class\hspace{6pt}for\hspace{6pt}topology\hspace{6pt}Copy\hspace{6pt}this\hspace{6pt}class\hspace{6pt}to\hspace{6pt}create\hspace{6pt}a\hspace{6pt}new\hspace{6pt}topology\hspace{6pt}for\hspace{6pt}som\string"}}{\texttt{\string"\string"}}\\
\hspace{24pt}{\textbf{def}}\hspace{6pt}\_\_init\_\_(self,G=None,Type={\texttt{{'}Graph{'}}}):\\
\hspace{48pt}som.\_\_init\_\_(self)\\
\hspace{48pt}self.Type\hspace{6pt}=\hspace{6pt}Type\\
\hspace{48pt}{\textbf{if}}\hspace{6pt}G:\\
\hspace{72pt}self.G\hspace{6pt}=\hspace{6pt}G\\
\hspace{72pt}self.Size\hspace{6pt}=\hspace{6pt}G.order()\\
\hspace{72pt}{\it{\#\hspace{6pt}if\hspace{6pt}findWidth\hspace{6pt}is\hspace{6pt}not\hspace{6pt}given\hspace{6pt}a\hspace{6pt}seed\hspace{6pt}it\hspace{6pt}will\hspace{6pt}brute\hspace{6pt}force\hspace{6pt}the\hspace{6pt}total\hspace{6pt}network}}\\
\hspace{72pt}{\it{\#\hspace{6pt}width,\hspace{6pt}this\hspace{6pt}could\hspace{6pt}take\hspace{6pt}a\hspace{6pt}long\hspace{6pt}time.\hspace{6pt}For\hspace{6pt}the\hspace{6pt}spherical\hspace{6pt}network,\hspace{6pt}one\hspace{6pt}of}}\\
\hspace{72pt}{\it{\#\hspace{6pt}the\hspace{6pt}polls\hspace{6pt}should\hspace{6pt}yield\hspace{6pt}the\hspace{6pt}correct\hspace{6pt}width.\hspace{6pt}Or\hspace{6pt}possibly\hspace{6pt}the\hspace{6pt}node\hspace{6pt}with}}\\
\hspace{72pt}{\it{\#\hspace{6pt}lowest\hspace{6pt}degree.}}\\
\hspace{72pt}self.Width\hspace{6pt}=\hspace{6pt}nf.findWidth(G,G.nodes(){[}\dash{}1{]})\hspace{6pt}\\
\hspace{72pt}{\it{\#WHY\hspace{6pt}WHY\hspace{6pt}WHY\hspace{6pt}WHY\hspace{6pt}WHY!!!!}}\\
\hspace{72pt}{\it{\#self.maxN\hspace{6pt}=\hspace{6pt}0.5}}\\
\\
\hspace{24pt}{\textbf{def}}\hspace{6pt}save(self,path,name):\\
\hspace{48pt}som.save(self,path,name)\\
\hspace{48pt}{\textbf{if}}\hspace{6pt}{\textbf{not}}\hspace{6pt}name:\\
\hspace{72pt}name\hspace{6pt}=\hspace{6pt}{\texttt{{'}\%ds\_\%dd\_\%dr\_\%fa{'}}}\%(self.Size,self.Dims,self.tSteps,self.alpha0)\\
\hspace{48pt}graphFile\hspace{6pt}=\hspace{6pt}path+name+{\texttt{{'}.graph{'}}}\\
\hspace{48pt}f\hspace{6pt}=\hspace{6pt}open(graphFile,{\texttt{{'}w{'}}})\\
\hspace{48pt}pickle.dump(self.G,f)\\
\hspace{48pt}f.close()\\
\hspace{24pt}{\textbf{def}}\hspace{6pt}load(self,path,name):\\
\hspace{48pt}som.load(self,path,name)\\
\hspace{48pt}{\textbf{if}}\hspace{6pt}{\textbf{not}}\hspace{6pt}name:\\
\hspace{72pt}name\hspace{6pt}=\hspace{6pt}{\texttt{{'}\%ds\_\%dd\_\%dr\_\%fa{'}}}\%(self.Size,self.Dims,self.tSteps,self.alpha0)\\
\hspace{48pt}graphFile\hspace{6pt}=\hspace{6pt}path+name+{\texttt{{'}.graph{'}}}\\
\hspace{48pt}{\textbf{if}}\hspace{6pt}os.path.exists(graphFile):\\
\hspace{72pt}f\hspace{6pt}=\hspace{6pt}open(graphFile,{\texttt{{'}r{'}}})\\
\hspace{72pt}self.G\hspace{6pt}=\hspace{6pt}G\hspace{6pt}=\hspace{6pt}pickle.load(f)\\
\hspace{72pt}self.Size\hspace{6pt}=\hspace{6pt}G.order()\\
\hspace{72pt}self.Width\hspace{6pt}=\hspace{6pt}nf.findWidth(G,G.nodes(){[}\dash{}1{]})\hspace{6pt}\\
\hspace{72pt}f.close()\\
\\
\hspace{24pt}{\textbf{def}}\hspace{6pt}randInit(self):\\
\hspace{48pt}som.randInit(self)\\
\hspace{24pt}{\textbf{def}}\hspace{6pt}kernalWidth(self,t):\\
\hspace{48pt}{\texttt{\string"\string"}}{\texttt{\string"}}\\
{\texttt{\hspace{48pt}kernalWidth\hspace{6pt}returns\hspace{6pt}the\hspace{6pt}width\hspace{6pt}of\hspace{6pt}the\hspace{6pt}neighborhood\hspace{6pt}in\hspace{6pt}terms\hspace{6pt}of\hspace{6pt}order}}\\
{\texttt{\hspace{48pt}\string"}}{\texttt{\string"\string"}}\\
\hspace{48pt}r\hspace{6pt}=\hspace{6pt}round((self.Width$\ast$self.maxN)\hspace{6pt}$\ast$\hspace{6pt}(1\hspace{6pt}\dash{}\hspace{6pt}(t/float(self.tSteps))))\\
\hspace{48pt}r\hspace{6pt}=\hspace{6pt}int(r)\\
\hspace{48pt}{\textbf{if}}\hspace{6pt}r\hspace{6pt}==\hspace{6pt}0:\hspace{6pt}r\hspace{6pt}=\hspace{6pt}1\\
\hspace{48pt}{\textbf{return}}\hspace{6pt}r\\
\hspace{24pt}{\textbf{def}}\hspace{6pt}odist(n):\\
\hspace{48pt}{\texttt{\string"\string"}}{\texttt{\string"}}\\
{\texttt{\hspace{48pt}n\hspace{6pt}is\hspace{6pt}the\hspace{6pt}nth\hspace{6pt}neuron\hspace{6pt}in\hspace{6pt}the\hspace{6pt}in\hspace{6pt}neighborhood,\hspace{6pt}return{'}s\hspace{6pt}order}}\\
{\texttt{\hspace{48pt}example\hspace{6pt}the\hspace{6pt}3rd\hspace{6pt}neuron\hspace{6pt}in\hspace{6pt}the\hspace{6pt}set\hspace{6pt}is\hspace{6pt}1\hspace{6pt}order\hspace{6pt}from\hspace{6pt}the\hspace{6pt}0th.}}\\
{\texttt{\hspace{48pt}\string"}}{\texttt{\string"\string"}}\\
\hspace{48pt}{\textbf{raise}}\hspace{6pt}{\texttt{\string"not\hspace{6pt}implemented\string"}}\\
\hspace{24pt}{\textbf{def}}\hspace{6pt}neighborhood(self,bmu,kernalWidth):\\
\hspace{48pt}{\texttt{\string"\string"}}{\texttt{\string"}}\\
{\texttt{\hspace{48pt}This\hspace{6pt}function\hspace{6pt}returns\hspace{6pt}a\hspace{6pt}dictionary\hspace{6pt}containing\hspace{6pt}the\hspace{6pt}neighbors\hspace{6pt}of\hspace{6pt}bmu\hspace{6pt}as}}\\
{\texttt{\hspace{48pt}keys\hspace{6pt}and\hspace{6pt}their\hspace{6pt}dist\hspace{6pt}(as\hspace{6pt}an\hspace{6pt}order)\hspace{6pt}as\hspace{6pt}values.}}\\
{\texttt{\hspace{48pt}\string"}}{\texttt{\string"\string"}}\\
\hspace{48pt}{\textbf{return}}\hspace{6pt}nf.neighborhood(self.G,bmu,kernalWidth)\\
\\
\hspace{24pt}{\textbf{def}}\hspace{6pt}hci2(self,\hspace{6pt}sigma,\hspace{6pt}a,\hspace{6pt}dist):\\
\hspace{48pt}top\hspace{6pt}=\hspace{6pt}dist$\ast$$\ast$2\\
\hspace{48pt}bottom\hspace{6pt}=\hspace{6pt}(2$\ast$(sigma$\ast$$\ast$2))\\
\hspace{48pt}{\textbf{return}}\hspace{6pt}a\hspace{6pt}$\ast$\hspace{6pt}math.exp(\dash{}top/bottom)\\
\hspace{24pt}{\textbf{def}}\hspace{6pt}merge(self,t,ind,v):\\
\hspace{48pt}{\texttt{\string"\string"}}{\texttt{\string"}}\\
{\texttt{\hspace{48pt}imporved\hspace{6pt}neighborhood\hspace{6pt}function\hspace{6pt}eliminates\hspace{6pt}the\hspace{6pt}need\hspace{6pt}for\hspace{6pt}odist\hspace{6pt}function.}}\\
{\texttt{\hspace{48pt}\string"}}{\texttt{\string"\string"}}\\
\hspace{48pt}bmu\hspace{6pt}=\hspace{6pt}self.findBMU(ind,v)\\
\hspace{48pt}a\hspace{6pt}=\hspace{6pt}self.alpha(t)\\
\hspace{48pt}sigma\hspace{6pt}=\hspace{6pt}self.kernalWidth(t)\\
\hspace{48pt}results\hspace{6pt}=\hspace{6pt}self.neighborhood(\hspace{6pt}bmu\hspace{6pt},\hspace{6pt}sigma\hspace{6pt})\\
\hspace{48pt}sigma\hspace{6pt}=\hspace{6pt}float(sigma)\\
\hspace{48pt}alteredNodes\hspace{6pt}=\hspace{6pt}{[}(node,(v\dash{}self.nodes{[}node{]})$\ast$(a$\ast$math.exp(\dash{}(odist$\ast$odist)/(2$\ast$sigma$\ast$sigma))))\hspace{6pt}{\textbf{for}}\hspace{6pt}node,odist\hspace{6pt}{\textbf{in}}\hspace{6pt}results.iteritems(){]}\\
\hspace{48pt}{\it{\#alteredNodes\hspace{6pt}=\hspace{6pt}{[}(node,(v\dash{}self.nodes{[}node{]})$\ast$self.hci2(sigma,a,odist))\hspace{6pt}for\hspace{6pt}node,odist\hspace{6pt}in\hspace{6pt}results.iteritems(){]}}}\\
\hspace{48pt}{\textbf{for}}\hspace{6pt}nodeID,node\hspace{6pt}{\textbf{in}}\hspace{6pt}alteredNodes:\\
\hspace{72pt}self.nodes{[}nodeID{]}\hspace{6pt}+=\hspace{6pt}node\\
\hspace{48pt}{\it{\#\hspace{6pt}trackking\hspace{6pt}diffs\hspace{6pt}slows\hspace{6pt}us\hspace{6pt}down.\hspace{6pt}a\hspace{6pt}lot.}}\\
\hspace{48pt}{\it{\#\hspace{24pt}self.diffs{[}nodeID{]}\hspace{6pt}+=\hspace{6pt}abs(delta)}}\\
\\
{\textbf{class}}\hspace{6pt}Sphere(som):\\
\hspace{24pt}{\textbf{def}}\hspace{6pt}\_\_init\_\_(self):\\
\hspace{48pt}som.\_\_init\_\_(self)\\
\hspace{48pt}{\it{\#\hspace{6pt}The\hspace{6pt}Cache\hspace{6pt}cache\hspace{6pt}only\hspace{6pt}works\hspace{6pt}if\hspace{6pt}the\hspace{6pt}Neighborhood\hspace{6pt}size\hspace{6pt}is\hspace{6pt}decreasing!}}\\
\hspace{48pt}{\it{\#\hspace{6pt}If\hspace{6pt}you\hspace{6pt}increase\hspace{6pt}the\hspace{6pt}maxN\hspace{6pt}clear\hspace{6pt}the\hspace{6pt}cache!}}\\
\hspace{48pt}self.neighborhoodCache\hspace{6pt}=\hspace{6pt}\{\}\\
\hspace{48pt}{\it{\#\hspace{6pt}WHY\hspace{6pt}WHY\hspace{6pt}WHY\hspace{6pt}WHY!!!!!}}\\
\hspace{48pt}{\it{\#\hspace{6pt}self.maxN\hspace{6pt}=\hspace{6pt}0.5}}\\
\hspace{24pt}{\textbf{def}}\hspace{6pt}clearCache(self):\\
\hspace{48pt}self.neighborhoodCache\hspace{6pt}=\hspace{6pt}\{\}\\
\hspace{24pt}{\textbf{def}}\hspace{6pt}randInit(self):\\
\hspace{48pt}som.randInit(self)\\
\hspace{48pt}N\hspace{6pt}=\hspace{6pt}self.Size\\
\hspace{48pt}points\hspace{6pt}=\hspace{6pt}{[}{]}\\
\hspace{48pt}{\textbf{for}}\hspace{6pt}i\hspace{6pt}{\textbf{in}}\hspace{6pt}xrange(1,N+1):\\
\hspace{72pt}i\hspace{6pt}=\hspace{6pt}float(i)\\
\hspace{72pt}N\hspace{6pt}=\hspace{6pt}float(N)\\
\hspace{72pt}h\hspace{6pt}=\hspace{6pt}(\dash{}1)+((2$\ast$(i\dash{}1))\hspace{6pt}/\hspace{6pt}(N\dash{}1))\\
\hspace{72pt}theta\hspace{6pt}=\hspace{6pt}acos(h)\\
\hspace{72pt}{\textbf{if}}\hspace{6pt}i\hspace{6pt}==\hspace{6pt}1\hspace{6pt}{\textbf{or}}\hspace{6pt}i\hspace{6pt}==\hspace{6pt}N:\\
\hspace{96pt}phi\hspace{6pt}=\hspace{6pt}0\\
\hspace{72pt}{\textbf{else:}}\\
\hspace{96pt}phi\hspace{6pt}=\hspace{6pt}(points{[}int(i)\dash{}2{]}{[}0{]}\hspace{6pt}+\hspace{6pt}(3.6/sqrt(N))\hspace{6pt}$\ast$\hspace{6pt}(1/sqrt(1\dash{}h$\ast$$\ast$2))\hspace{6pt})\hspace{6pt}\%\hspace{6pt}(2$\ast$pi)\\
\hspace{72pt}points.append((phi,theta))\\
\hspace{48pt}points\hspace{6pt}=\hspace{6pt}array({[}(phi\dash{}pi,theta\dash{}(pi/2))\hspace{6pt}{\textbf{for}}\hspace{6pt}phi,theta\hspace{6pt}{\textbf{in}}\hspace{6pt}points{]})\\
\hspace{48pt}self.grid\hspace{6pt}=\hspace{6pt}points\\
\\
\hspace{48pt}size\hspace{6pt}=\hspace{6pt}self.Size\hspace{6pt}$\ast$\hspace{6pt}self.maxN\\
\hspace{48pt}maxW\hspace{6pt}=\hspace{6pt}0\\
\hspace{48pt}W\hspace{6pt}=\hspace{6pt}0\\
\hspace{48pt}{\textbf{while}}\hspace{6pt}size\hspace{6pt}$>$=\hspace{6pt}(1+(3$\ast$maxW)$\ast$(maxW\dash{}1)):\\
\hspace{72pt}maxW\hspace{6pt}+=\hspace{6pt}1\\
\hspace{48pt}self.maxW\hspace{6pt}=\hspace{6pt}maxW\\
\\
\hspace{24pt}{\textbf{def}}\hspace{6pt}odist(self,n):\\
\hspace{48pt}d\hspace{6pt}=\hspace{6pt}1\\
\hspace{48pt}{\textbf{while}}\hspace{6pt}n\hspace{6pt}$>$=\hspace{6pt}(1+(3$\ast$d)$\ast$(d\dash{}1)):\\
\hspace{72pt}d+=1\\
\hspace{48pt}{\textbf{return}}\hspace{6pt}d\dash{}1\\
\hspace{24pt}{\textbf{def}}\hspace{6pt}save(self,path,name):\\
\hspace{48pt}som.save(self,path,name)\\
\hspace{48pt}geof\hspace{6pt}=\hspace{6pt}open(path+name+{\texttt{{'}\_geo.txt{'}}},{\texttt{{'}w{'}}})\\
\hspace{48pt}geof.write({\texttt{\string"\%d\hspace{6pt}\%d$\backslash$n\string"}}\%(self.Dims,self.Size))\\
\hspace{48pt}{\textbf{for}}\hspace{6pt}i\hspace{6pt}{\textbf{in}}\hspace{6pt}xrange(self.Size):\\
\hspace{72pt}geof.write({\texttt{\string"\%f\hspace{6pt}\%f$\backslash$n\string"}}\%(degrees(self.grid{[}i{]}{[}0{]}),degrees(self.grid{[}i{]}{[}1{]})))\\
\hspace{48pt}geof.close()\\
\hspace{24pt}{\textbf{def}}\hspace{6pt}load(self,path,name):\\
\hspace{48pt}som.load(self,path,name)\\
\hspace{48pt}{\textbf{if}}\hspace{6pt}os.path.exists(path+name+{\texttt{{'}\_geo.txt{'}}}):\\
\hspace{72pt}geof\hspace{6pt}=\hspace{6pt}open(path+name+{\texttt{{'}\_geo.txt{'}}},{\texttt{{'}r{'}}})\\
\hspace{72pt}header\hspace{6pt}=\hspace{6pt}geof.next()\\
\hspace{72pt}self.grid\hspace{6pt}=\hspace{6pt}zeros((self.Size,2),{\texttt{{'}float{'}}})\\
\hspace{72pt}{\textbf{for}}\hspace{6pt}i\hspace{6pt}{\textbf{in}}\hspace{6pt}xrange(self.Size):\\
\hspace{96pt}geo\hspace{6pt}=\hspace{6pt}geof.next()\\
\hspace{96pt}geo\hspace{6pt}=\hspace{6pt}geo.split()\\
\hspace{96pt}geo\hspace{6pt}=\hspace{6pt}(math.radians(float(geo{[}0{]})),math.radians(float(geo{[}1{]})))\\
\hspace{96pt}self.grid{[}i{]}\hspace{6pt}=\hspace{6pt}geo\\
\hspace{48pt}{\textbf{else:}}\\
\hspace{72pt}{\textbf{pass}}\\
\hspace{24pt}{\textbf{def}}\hspace{6pt}sdist(self,pt1,pt2):\\
\hspace{48pt}phi1,theta1\hspace{6pt}=\hspace{6pt}pt1\\
\hspace{48pt}phi2,theta2\hspace{6pt}=\hspace{6pt}pt2\\
\hspace{48pt}dphi\hspace{6pt}=\hspace{6pt}phi2\hspace{6pt}\dash{}\hspace{6pt}phi1\\
\hspace{48pt}dtheta\hspace{6pt}=\hspace{6pt}theta2\hspace{6pt}\dash{}\hspace{6pt}theta1\\
\hspace{48pt}a\hspace{6pt}=\hspace{6pt}sin(dtheta/2)$\ast$$\ast$2\hspace{6pt}+\hspace{6pt}(cos(theta1)\hspace{6pt}$\ast$\hspace{6pt}cos(theta2)\hspace{6pt}$\ast$\hspace{6pt}sin(dphi/2)$\ast$$\ast$2)\\
\hspace{48pt}c\hspace{6pt}=\hspace{6pt}2\hspace{6pt}$\ast$\hspace{6pt}asin(min(1,sqrt(a)))\\
\hspace{48pt}{\textbf{return}}\hspace{6pt}c\\
\hspace{24pt}{\textbf{def}}\hspace{6pt}kernalWidth(self,t):\\
\hspace{48pt}r\hspace{6pt}=\hspace{6pt}round((self.maxW)\hspace{6pt}$\ast$\hspace{6pt}(1\hspace{6pt}\dash{}\hspace{6pt}(t/float(self.tSteps))))\\
\hspace{48pt}r\hspace{6pt}=\hspace{6pt}int(r)\\
\hspace{48pt}{\textbf{if}}\hspace{6pt}r\hspace{6pt}==\hspace{6pt}0:\hspace{6pt}r\hspace{6pt}=\hspace{6pt}1\\
\hspace{48pt}{\textbf{return}}\hspace{6pt}r\\
\hspace{24pt}{\textbf{def}}\hspace{6pt}neighborhood(self,bmu,sigma):\\
\hspace{48pt}NumNeighbors\hspace{6pt}=\hspace{6pt}(1+(3$\ast$sigma)$\ast$(sigma\dash{}1))\\
\hspace{48pt}{\textbf{try:}}\\
\hspace{72pt}{\textbf{return}}\hspace{6pt}self.neighborhoodCache{[}bmu{]}{[}:NumNeighbors{]}\\
\hspace{48pt}{\textbf{except:}}\\
\hspace{72pt}pt0\hspace{6pt}=\hspace{6pt}self.grid{[}bmu{]}\\
\hspace{72pt}dists\hspace{6pt}=\hspace{6pt}\{\}\\
\hspace{72pt}{\textbf{for}}\hspace{6pt}i\hspace{6pt}{\textbf{in}}\hspace{6pt}xrange(self.Size):\\
\hspace{96pt}dists{[}self.sdist(self.grid{[}i{]},pt0){]}\hspace{6pt}=\hspace{6pt}i\\
\hspace{72pt}keys\hspace{6pt}=\hspace{6pt}dists.keys()\\
\hspace{72pt}keys.sort()\hspace{6pt}\\
\hspace{72pt}pts\hspace{6pt}=\hspace{6pt}{[}dists{[}keys{[}i{]}{]}\hspace{6pt}{\textbf{for}}\hspace{6pt}i\hspace{6pt}{\textbf{in}}\hspace{6pt}xrange(NumNeighbors){]}\\
\hspace{72pt}self.neighborhoodCache{[}bmu{]}\hspace{6pt}=\hspace{6pt}pts\\
\hspace{72pt}{\textbf{return}}\hspace{6pt}pts\\
\\
{\textbf{class}}\hspace{6pt}ObsFile:\\
\hspace{24pt}{\textbf{def}}\hspace{6pt}\_\_init\_\_(self,filename,fileType\hspace{6pt}=\hspace{6pt}{\texttt{{'}complete{'}}}):\\
\hspace{48pt}self.filename\hspace{6pt}=\hspace{6pt}filename\\
\hspace{48pt}self.fileObj\hspace{6pt}=\hspace{6pt}open(filename,{\texttt{{'}r{'}}})\\
\hspace{48pt}self.fileType\hspace{6pt}=\hspace{6pt}fileType\\
\hspace{48pt}self.reset()\\
\hspace{24pt}{\textbf{def}}\hspace{6pt}\_\_iter\_\_(self):\\
\hspace{48pt}{\textbf{return}}\hspace{6pt}self\\
\hspace{24pt}{\textbf{def}}\hspace{6pt}listolists(self,comments=False):\\
\hspace{48pt}self.fileObj.seek(0)\\
\hspace{48pt}lines\hspace{6pt}=\hspace{6pt}self.fileObj.readlines()\\
\hspace{48pt}dims\hspace{6pt}=\hspace{6pt}lines.pop(0)\\
\hspace{48pt}dims\hspace{6pt}=\hspace{6pt}int(dims)\\
\hspace{48pt}lines\hspace{6pt}=\hspace{6pt}{[}line.split()\hspace{6pt}{\textbf{for}}\hspace{6pt}line\hspace{6pt}{\textbf{in}}\hspace{6pt}lines{]}\\
\hspace{48pt}{\textbf{if}}\hspace{6pt}{\textbf{not}}\hspace{6pt}comments:\\
\hspace{72pt}lines\hspace{6pt}=\hspace{6pt}{[}line{[}:dims{]}\hspace{6pt}{\textbf{for}}\hspace{6pt}line\hspace{6pt}{\textbf{in}}\hspace{6pt}lines{]}\\
\hspace{72pt}lines\hspace{6pt}=\hspace{6pt}{[}array(map(float,line),{\texttt{{'}float{'}}})\hspace{6pt}{\textbf{for}}\hspace{6pt}line\hspace{6pt}{\textbf{in}}\hspace{6pt}lines{]}\\
\hspace{48pt}{\textbf{else:}}\\
\hspace{72pt}lines\hspace{6pt}=\hspace{6pt}{[}line{[}dims:{]}\hspace{6pt}{\textbf{for}}\hspace{6pt}line\hspace{6pt}{\textbf{in}}\hspace{6pt}lines{]}\\
\hspace{48pt}{\textbf{return}}\hspace{6pt}lines\\
\hspace{24pt}{\textbf{def}}\hspace{6pt}Snext(self):\\
\hspace{48pt}line\hspace{6pt}=\hspace{6pt}self.fileObj.next()\\
\hspace{48pt}id,line\hspace{6pt}=\hspace{6pt}line.split({\texttt{{'}:{'}}})\\
\hspace{48pt}line\hspace{6pt}=\hspace{6pt}line.split({\texttt{{'},{'}}})\\
\hspace{48pt}Num\hspace{6pt}=\hspace{6pt}len(line)/2\\
\hspace{48pt}indices\hspace{6pt}=\hspace{6pt}empty(Num,{\texttt{{'}int16{'}}})\\
\hspace{48pt}values\hspace{6pt}=\hspace{6pt}empty(Num,{\texttt{{'}float{'}}})\\
\hspace{48pt}c\hspace{6pt}=\hspace{6pt}0\\
\hspace{48pt}{\textbf{for}}\hspace{6pt}n\hspace{6pt}{\textbf{in}}\hspace{6pt}xrange(0,Num$\ast$2,2):\\
\hspace{72pt}indices{[}c{]}\hspace{6pt}=\hspace{6pt}int(line{[}n{]})\dash{}1\\
\hspace{72pt}values{[}c{]}\hspace{6pt}=\hspace{6pt}float(line{[}n+1{]})\\
\hspace{72pt}c\hspace{6pt}+=\hspace{6pt}1\\
\hspace{48pt}{\textbf{return}}\hspace{6pt}id,indices,values\\
\hspace{24pt}{\textbf{def}}\hspace{6pt}Cnext(self):\\
\hspace{48pt}line\hspace{6pt}=\hspace{6pt}self.fileObj.next()\\
\hspace{48pt}line\hspace{6pt}=\hspace{6pt}line.split()\\
\hspace{48pt}id\hspace{6pt}=\hspace{6pt}self.nextLine\\
\hspace{48pt}{\textbf{for}}\hspace{6pt}n\hspace{6pt}{\textbf{in}}\hspace{6pt}xrange(0,self.Dims):\\
\hspace{72pt}self.values{[}n{]}\hspace{6pt}=\hspace{6pt}float(line{[}n{]})\\
\hspace{48pt}self.nextLine+=1\\
\hspace{48pt}{\textbf{return}}\hspace{6pt}id,self.indices,self.values\\
\hspace{24pt}{\textbf{def}}\hspace{6pt}reset(self):\\
\hspace{48pt}self.fileObj.seek(0)\\
\hspace{48pt}self.nextLine\hspace{6pt}=\hspace{6pt}0\hspace{6pt}{\it{\#Zero\hspace{6pt}Base}}\\
\hspace{48pt}{\textbf{if}}\hspace{6pt}self.fileType\hspace{6pt}==\hspace{6pt}{\texttt{{'}complete{'}}}:\\
\hspace{72pt}self.next\hspace{6pt}=\hspace{6pt}self.Cnext\\
\hspace{72pt}self.Dims\hspace{6pt}=\hspace{6pt}int(self.fileObj.next())\\
\hspace{72pt}self.indices\hspace{6pt}=\hspace{6pt}array(range(self.Dims),{\texttt{{'}int16{'}}})\hspace{6pt}\\
\hspace{72pt}self.values\hspace{6pt}=\hspace{6pt}empty(self.Dims,{\texttt{{'}float{'}}})\hspace{6pt}\\
\hspace{48pt}{\textbf{elif}}\hspace{6pt}self.fileType\hspace{6pt}==\hspace{6pt}{\texttt{{'}sparse{'}}}:\\
\hspace{72pt}self.next\hspace{6pt}=\hspace{6pt}self.Snext\\
\hspace{48pt}{\textbf{else:}}\\
\hspace{72pt}{\textbf{raise}}\hspace{6pt}{\texttt{\string"fileTypeError\string"}}\\
\hspace{24pt}{\textbf{def}}\hspace{6pt}stream(self):\\
\hspace{48pt}{\textbf{try:}}\\
\hspace{72pt}{\textbf{return}}\hspace{6pt}self.next()\\
\hspace{48pt}{\textbf{except:}}\\
\hspace{72pt}self.reset()\\
\hspace{72pt}{\textbf{return}}\hspace{6pt}self.next()\\
\hspace{24pt}{\textbf{def}}\hspace{6pt}close(self):\\
\hspace{48pt}self.fileObj.close()
\end{tabbing}}}
