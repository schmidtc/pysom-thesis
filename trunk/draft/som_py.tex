{{\def\dash{\raise2.1pt\hbox{\rule{5pt}{0.3pt}}\hspace{1pt}}\begin{tabbing}
{\texttt{\string"\string"}}{\texttt{\string"}}\\
{\texttt{======================================================================}}\\
{\texttt{Python\hspace{6pt}Self\dash{}Organizing\hspace{6pt}Maps\hspace{6pt}}}\\
{\texttt{\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}}}\\
{\texttt{AUTHOR(S):\hspace{36pt}Charles\hspace{6pt}R.\hspace{6pt}Schmidt\hspace{6pt}cschmidt@rohan.sdsu.edu}}\\
{\texttt{\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}\dash{}}}\\
{\texttt{$\ast$\hspace{6pt}Copyright\hspace{6pt}(c)\hspace{6pt}2006\dash{}2008,\hspace{6pt}Charles\hspace{6pt}R.\hspace{6pt}Schmidt}}\\
{\texttt{$\ast$\hspace{6pt}All\hspace{6pt}rights\hspace{6pt}reserved.}}\\
{\texttt{$\ast$}}\\
{\texttt{$\ast$\hspace{6pt}Redistribution\hspace{6pt}and\hspace{6pt}use\hspace{6pt}in\hspace{6pt}source\hspace{6pt}and\hspace{6pt}binary\hspace{6pt}forms,\hspace{6pt}with\hspace{6pt}or\hspace{6pt}without}}\\
{\texttt{$\ast$\hspace{6pt}modification,\hspace{6pt}are\hspace{6pt}permitted\hspace{6pt}provided\hspace{6pt}that\hspace{6pt}the\hspace{6pt}following\hspace{6pt}conditions}}\\
{\texttt{$\ast$\hspace{6pt}are\hspace{6pt}met:}}\\
{\texttt{$\ast$\hspace{30pt}$\ast$\hspace{6pt}Redistributions\hspace{6pt}of\hspace{6pt}source\hspace{6pt}code\hspace{6pt}must\hspace{6pt}retain\hspace{6pt}the\hspace{6pt}above\hspace{6pt}copyright}}\\
{\texttt{$\ast$\hspace{42pt}notice,\hspace{6pt}this\hspace{6pt}list\hspace{6pt}of\hspace{6pt}conditions\hspace{6pt}and\hspace{6pt}the\hspace{6pt}following\hspace{6pt}disclaimer.}}\\
{\texttt{$\ast$\hspace{30pt}$\ast$\hspace{6pt}Redistributions\hspace{6pt}in\hspace{6pt}binary\hspace{6pt}form\hspace{6pt}must\hspace{6pt}reproduce\hspace{6pt}the\hspace{6pt}above}}\\
{\texttt{$\ast$\hspace{42pt}copyright\hspace{6pt}notice,\hspace{6pt}this\hspace{6pt}list\hspace{6pt}of\hspace{6pt}conditions\hspace{6pt}and\hspace{6pt}the\hspace{6pt}following}}\\
{\texttt{$\ast$\hspace{42pt}disclaimer\hspace{6pt}in\hspace{6pt}the\hspace{6pt}documentation\hspace{6pt}and/or\hspace{6pt}other\hspace{6pt}materials}}\\
{\texttt{$\ast$\hspace{42pt}provided\hspace{6pt}with\hspace{6pt}the\hspace{6pt}distribution.}}\\
{\texttt{$\ast$\hspace{30pt}$\ast$\hspace{6pt}Neither\hspace{6pt}the\hspace{6pt}name\hspace{6pt}of\hspace{6pt}the\hspace{6pt}San\hspace{6pt}Diego\hspace{6pt}State\hspace{6pt}University\hspace{6pt}nor\hspace{6pt}the}}\\
{\texttt{$\ast$\hspace{42pt}names\hspace{6pt}of\hspace{6pt}its\hspace{6pt}contributors\hspace{6pt}may\hspace{6pt}be\hspace{6pt}used\hspace{6pt}to\hspace{6pt}endorse\hspace{6pt}or\hspace{6pt}promote}}\\
{\texttt{$\ast$\hspace{42pt}products\hspace{6pt}derived\hspace{6pt}from\hspace{6pt}this\hspace{6pt}software\hspace{6pt}without\hspace{6pt}specific\hspace{6pt}prior}}\\
{\texttt{$\ast$\hspace{42pt}written\hspace{6pt}permission.}}\\
{\texttt{$\ast$}}\\
{\texttt{$\ast$\hspace{6pt}THIS\hspace{6pt}SOFTWARE\hspace{6pt}IS\hspace{6pt}PROVIDED\hspace{6pt}BY\hspace{6pt}Charles\hspace{6pt}R.\hspace{6pt}Schmidt\hspace{6pt}{'}{'}AS\hspace{6pt}IS{'}{'}\hspace{6pt}AND\hspace{6pt}ANY}}\\
{\texttt{$\ast$\hspace{6pt}EXPRESS\hspace{6pt}OR\hspace{6pt}IMPLIED\hspace{6pt}WARRANTIES,\hspace{6pt}INCLUDING,\hspace{6pt}BUT\hspace{6pt}NOT\hspace{6pt}LIMITED\hspace{6pt}TO,\hspace{6pt}THE}}\\
{\texttt{$\ast$\hspace{6pt}IMPLIED\hspace{6pt}WARRANTIES\hspace{6pt}OF\hspace{6pt}MERCHANTABILITY\hspace{6pt}AND\hspace{6pt}FITNESS\hspace{6pt}FOR\hspace{6pt}A\hspace{6pt}PARTICULAR}}\\
{\texttt{$\ast$\hspace{6pt}PURPOSE\hspace{6pt}ARE\hspace{6pt}DISCLAIMED.\hspace{6pt}IN\hspace{6pt}NO\hspace{6pt}EVENT\hspace{6pt}SHALL\hspace{6pt}Charles\hspace{6pt}R.\hspace{6pt}Schmidt\hspace{6pt}BE}}\\
{\texttt{$\ast$\hspace{6pt}LIABLE\hspace{6pt}FOR\hspace{6pt}ANY\hspace{6pt}DIRECT,\hspace{6pt}INDIRECT,\hspace{6pt}INCIDENTAL,\hspace{6pt}SPECIAL,\hspace{6pt}EXEMPLARY,\hspace{6pt}OR}}\\
{\texttt{$\ast$\hspace{6pt}CONSEQUENTIAL\hspace{6pt}DAMAGES\hspace{6pt}(INCLUDING,\hspace{6pt}BUT\hspace{6pt}NOT\hspace{6pt}LIMITED\hspace{6pt}TO,\hspace{6pt}PROCUREMENT\hspace{6pt}OF}}\\
{\texttt{$\ast$\hspace{6pt}SUBSTITUTE\hspace{6pt}GOODS\hspace{6pt}OR\hspace{6pt}SERVICES;\hspace{6pt}LOSS\hspace{6pt}OF\hspace{6pt}USE,\hspace{6pt}DATA,\hspace{6pt}OR\hspace{6pt}PROFITS;\hspace{6pt}OR}}\\
{\texttt{$\ast$\hspace{6pt}BUSINESS\hspace{6pt}INTERRUPTION)\hspace{6pt}HOWEVER\hspace{6pt}CAUSED\hspace{6pt}AND\hspace{6pt}ON\hspace{6pt}ANY\hspace{6pt}THEORY\hspace{6pt}OF}}\\
{\texttt{$\ast$\hspace{6pt}LIABILITY,\hspace{6pt}WHETHER\hspace{6pt}IN\hspace{6pt}CONTRACT,\hspace{6pt}STRICT\hspace{6pt}LIABILITY,\hspace{6pt}OR\hspace{6pt}TORT\hspace{6pt}(INCLUDING}}\\
{\texttt{$\ast$\hspace{6pt}NEGLIGENCE\hspace{6pt}OR\hspace{6pt}OTHERWISE)\hspace{6pt}ARISING\hspace{6pt}IN\hspace{6pt}ANY\hspace{6pt}WAY\hspace{6pt}OUT\hspace{6pt}OF\hspace{6pt}THE\hspace{6pt}USE\hspace{6pt}OF\hspace{6pt}THIS}}\\
{\texttt{$\ast$\hspace{6pt}SOFTWARE,\hspace{6pt}EVEN\hspace{6pt}IF\hspace{6pt}ADVISED\hspace{6pt}OF\hspace{6pt}THE\hspace{6pt}POSSIBILITY\hspace{6pt}OF\hspace{6pt}SUCH\hspace{6pt}DAMAGE.}}\\
{\texttt{======================================================================}}\\
{\texttt{\string"}}{\texttt{\string"\string"}}\\
{\it{\#\hspace{6pt}Standard\hspace{6pt}Libraries}}\\
{\textbf{import}}\hspace{6pt}random,math,time,sys,os\\
{\textbf{from}}\hspace{6pt}math\hspace{6pt}{\textbf{import}}\hspace{6pt}acos,sqrt,pi,degrees,sin,cos,asin\\
{\textbf{import}}\hspace{6pt}pickle\hspace{6pt}{\it{\#provides\hspace{6pt}object\hspace{6pt}serialization}}\\
\\
{\it{\#\hspace{6pt}External\hspace{6pt}Libraries}}\\
{\it{\#\hspace{6pt}http://numpy.scipy.org/}}\\
{\textbf{from}}\hspace{6pt}numpy\hspace{6pt}{\textbf{import}}\hspace{6pt}array,empty,take,put,zeros\\
{\textbf{import}}\hspace{6pt}numpy\hspace{6pt}as\hspace{6pt}N\\
{\it{\#\hspace{6pt}https://networkx.lanl.gov/}}\\
{\textbf{import}}\hspace{6pt}networkx\hspace{6pt}as\hspace{6pt}NX\\
\\
{\it{\#\hspace{6pt}Local\hspace{6pt}Libraries\hspace{6pt}(part\hspace{6pt}of\hspace{6pt}pySom)}}\\
{\textbf{import}}\hspace{6pt}networkFunctions\hspace{6pt}as\hspace{6pt}nf\\
{\textbf{from}}\hspace{6pt}data\hspace{6pt}{\textbf{import}}\hspace{6pt}ObsFile\\
\\
{\textbf{class}}\hspace{6pt}som:\\
\hspace{24pt}{\texttt{{'}{'}}}{\texttt{{'}\hspace{6pt}Base\hspace{6pt}class\hspace{6pt}for\hspace{6pt}the\hspace{6pt}Self\dash{}Organizing\hspace{6pt}Map,}}\\
{\texttt{\hspace{48pt}Each\hspace{6pt}topology\hspace{6pt}will\hspace{6pt}inherit\hspace{6pt}from\hspace{6pt}this\hspace{6pt}class.}}\\
{\texttt{\hspace{48pt}A\hspace{6pt}template\hspace{6pt}is\hspace{6pt}provied\hspace{6pt}in\hspace{6pt}{'}}}Topology{\texttt{{'}}}\\
{\texttt{\hspace{24pt}{'}}}{\texttt{{'}{'}}}\\
\hspace{24pt}{\textbf{def}}\hspace{6pt}\_\_init\_\_(self):\\
\hspace{48pt}{\texttt{{'}{'}}}{\texttt{{'}}}\\
{\texttt{\hspace{48pt}These\hspace{6pt}initial\hspace{6pt}training\hspace{6pt}parameters\hspace{6pt}should\hspace{6pt}be}}\\
{\texttt{\hspace{48pt}set\hspace{6pt}before\hspace{6pt}training.}}\\
{\texttt{\hspace{48pt}{'}}}{\texttt{{'}{'}}}\\
\hspace{48pt}{\it{\#\hspace{6pt}int,\hspace{6pt}the\hspace{6pt}number\hspace{6pt}of\hspace{6pt}dimmension\hspace{6pt}in\hspace{6pt}the\hspace{6pt}input\dash{}space}}\\
\hspace{48pt}self.Dims\hspace{6pt}=\hspace{6pt}0\\
\hspace{48pt}{\it{\#\hspace{6pt}int,\hspace{6pt}optionally\hspace{6pt}the\hspace{6pt}number\hspace{6pt}nurons\hspace{6pt}in\hspace{6pt}the\hspace{6pt}X\hspace{6pt}dimmension}}\\
\hspace{48pt}self.X\hspace{6pt}=\hspace{6pt}0\\
\hspace{48pt}{\it{\#\hspace{6pt}int,\hspace{6pt}optionally\hspace{6pt}the\hspace{6pt}number\hspace{6pt}nurons\hspace{6pt}in\hspace{6pt}the\hspace{6pt}Y\hspace{6pt}dimmension}}\\
\hspace{48pt}self.Y\hspace{6pt}=\hspace{6pt}0\\
\hspace{48pt}{\it{\#\hspace{6pt}int,\hspace{6pt}total\hspace{6pt}number\hspace{6pt}of\hspace{6pt}neurons}}\\
\hspace{48pt}self.Size\hspace{6pt}=\hspace{6pt}0\\
\hspace{48pt}{\it{\#\hspace{6pt}str,\hspace{6pt}name\hspace{6pt}of\hspace{6pt}topology\hspace{6pt}type}}\\
\hspace{48pt}self.Type\hspace{6pt}=\hspace{6pt}{\texttt{{'}none{'}}}\\
\hspace{48pt}{\it{\#\hspace{6pt}int,\hspace{6pt}total\hspace{6pt}number\hspace{6pt}of\hspace{6pt}training\hspace{6pt}steps.}}\\
\hspace{48pt}self.tSteps\hspace{6pt}=\hspace{6pt}0\\
\hspace{48pt}{\it{\#\hspace{6pt}float,\hspace{6pt}initial\hspace{6pt}neighborhood\hspace{6pt}radius,\hspace{6pt}expressed\hspace{6pt}as\hspace{6pt}percentage.}}\\
\hspace{48pt}self.maxN\hspace{6pt}=\hspace{6pt}0.0\\
\hspace{48pt}{\it{\#\hspace{6pt}float,\hspace{6pt}initial\hspace{6pt}learning\hspace{6pt}rate}}\\
\hspace{48pt}self.alpha0\hspace{6pt}=\hspace{6pt}0.0\\
\\
\hspace{48pt}{\it{\#\hspace{6pt}reference\hspace{6pt}vecotors\hspace{6pt}are\hspace{6pt}stored\hspace{6pt}here.}}\\
\hspace{48pt}self.nodes\hspace{6pt}=\hspace{6pt}{[}{]}\\
\hspace{48pt}{\it{\#\hspace{6pt}mapping\hspace{6pt}of\hspace{6pt}observations\hspace{6pt}to\hspace{6pt}neurons\hspace{6pt}is\hspace{6pt}stored\hspace{6pt}here.}}\\
\hspace{48pt}self.daMap\hspace{6pt}=\hspace{6pt}\{\}\\
\\
\hspace{24pt}{\textbf{def}}\hspace{6pt}load(self,path={\texttt{{'}{'}}},name=None):\\
\hspace{48pt}{\texttt{{'}{'}}}{\texttt{{'}\hspace{6pt}This\hspace{6pt}function\hspace{6pt}loads\hspace{6pt}a\hspace{6pt}saved\hspace{6pt}SOM\hspace{6pt}from\hspace{6pt}disk\hspace{6pt}into\hspace{6pt}memory.}}\\
{\texttt{\hspace{72pt}pySom\hspace{6pt}uses\hspace{6pt}several\hspace{6pt}files\hspace{6pt}to\hspace{6pt}represent\hspace{6pt}the\hspace{6pt}SOM,}}\\
{\texttt{\hspace{72pt}.cod\hspace{6pt}is\hspace{6pt}the\hspace{6pt}Codebook\hspace{6pt}file\hspace{6pt}which\hspace{6pt}represents\hspace{6pt}the}}\\
{\texttt{\hspace{96pt}reference\hspace{6pt}vectors}}\\
{\texttt{\hspace{72pt}.map\hspace{6pt}represents\hspace{6pt}the\hspace{6pt}mapping\hspace{6pt}of\hspace{6pt}the\hspace{6pt}observations}}\\
{\texttt{\hspace{96pt}onto\hspace{6pt}the\hspace{6pt}trained\hspace{6pt}SOM}}\\
{\texttt{\hspace{72pt}}}\\
{\texttt{\hspace{72pt}If\hspace{6pt}the\hspace{6pt}path\hspace{6pt}and\hspace{6pt}name\hspace{6pt}are\hspace{6pt}omitted\hspace{6pt}they\hspace{6pt}will\hspace{6pt}be\hspace{6pt}guessed\hspace{6pt}}}\\
{\texttt{\hspace{72pt}based\hspace{6pt}on\hspace{6pt}the\hspace{6pt}SOM{'}}}s\hspace{6pt}parameters\\
\hspace{48pt}{\texttt{{'}{'}}}{\texttt{{'}}}\\
{\texttt{\hspace{48pt}if\hspace{6pt}not\hspace{6pt}name:}}\\
{\texttt{\hspace{72pt}name\hspace{6pt}=\hspace{6pt}{'}}}\%ds\_\%dd\_\%dr\_\%fa{\texttt{{'}\%(self.Size,self.Dims,self.tSteps,}}{}...\`$\Rightarrow$\\
...{}{\texttt{self.alpha0)}}\\
{\texttt{\hspace{48pt}codname\hspace{6pt}=\hspace{6pt}path+name+{'}}}.cod{\texttt{{'}}}\\
{\texttt{\hspace{48pt}mapname\hspace{6pt}=\hspace{6pt}path+name+{'}}}.map{\texttt{{'}}}\\
{\texttt{\hspace{48pt}if\hspace{6pt}os.path.exists(mapname):}}\\
{\texttt{\hspace{72pt}try:}}\\
{\texttt{\hspace{96pt}f\hspace{6pt}=\hspace{6pt}open(mapname,{'}}}r{\texttt{{'})}}\\
{\texttt{\hspace{96pt}self.daMap\hspace{6pt}=\hspace{6pt}pickle.load(f)}}\\
{\texttt{\hspace{96pt}f.close()}}\\
{\texttt{\hspace{72pt}except:}}\\
{\texttt{\hspace{96pt}self.daMap\hspace{6pt}=\hspace{6pt}\{\}}}\\
{\texttt{\hspace{48pt}dataf\hspace{6pt}=\hspace{6pt}open(codname,{'}}}r{\texttt{{'})}}\\
{\texttt{\hspace{48pt}header\hspace{6pt}=\hspace{6pt}dataf.next()}}\\
{\texttt{\hspace{48pt}Dims,Type,x,y,nType=\hspace{6pt}header.split()}}\\
{\texttt{\hspace{48pt}self.Dims\hspace{6pt}=\hspace{6pt}int(Dims)}}\\
{\texttt{\hspace{48pt}self.Type\hspace{6pt}=\hspace{6pt}Type}}\\
{\texttt{\hspace{48pt}self.X,\hspace{6pt}self.Y\hspace{6pt}=\hspace{6pt}int(x),int(y)}}\\
{\texttt{\hspace{48pt}self.Size\hspace{6pt}=\hspace{6pt}self.X$\ast$self.Y}}\\
{\texttt{\hspace{48pt}self.nodes\hspace{6pt}=\hspace{6pt}array({[}{[}0.0\hspace{6pt}for\hspace{6pt}i\hspace{6pt}in\hspace{6pt}xrange(self.Dims){]}\hspace{6pt}for\hspace{6pt}j\hspace{6pt}in\hspace{6pt}}}{}...\`$\Rightarrow$\\
...{}{\texttt{xrange(self.Size){]})}}\\
{\texttt{\hspace{48pt}for\hspace{6pt}i\hspace{6pt}in\hspace{6pt}xrange(self.Size):}}\\
{\texttt{\hspace{72pt}data\hspace{6pt}=\hspace{6pt}dataf.next()}}\\
{\texttt{\hspace{72pt}data\hspace{6pt}=\hspace{6pt}data.split()}}\\
{\texttt{\hspace{72pt}data\hspace{6pt}=\hspace{6pt}map(float,data)}}\\
{\texttt{\hspace{72pt}self.nodes{[}i{]}\hspace{6pt}=\hspace{6pt}data}}\\
\\
{\texttt{\hspace{24pt}def\hspace{6pt}save(self,path={'}}}{\texttt{{'},name=None):}}\\
{\texttt{\hspace{48pt}{'}}}{\texttt{{'}{'}}}\hspace{6pt}This\hspace{6pt}function\hspace{6pt}saves\hspace{6pt}a\hspace{6pt}SOM\hspace{6pt}to\hspace{6pt}disk.\\
\hspace{72pt}pySom\hspace{6pt}uses\hspace{6pt}several\hspace{6pt}files\hspace{6pt}to\hspace{6pt}represent\hspace{6pt}the\hspace{6pt}SOM,\\
\hspace{72pt}.cod\hspace{6pt}{\textbf{is}}\hspace{6pt}the\hspace{6pt}Codebook\hspace{6pt}file\hspace{6pt}which\hspace{6pt}represents\hspace{6pt}the\\
\hspace{96pt}reference\hspace{6pt}vectors\\
\hspace{72pt}.map\hspace{6pt}represents\hspace{6pt}the\hspace{6pt}mapping\hspace{6pt}of\hspace{6pt}the\hspace{6pt}observations\\
\hspace{96pt}onto\hspace{6pt}the\hspace{6pt}trained\hspace{6pt}SOM\\
\hspace{72pt}\\
\hspace{72pt}{\textbf{If}}\hspace{6pt}the\hspace{6pt}path\hspace{6pt}{\textbf{and}}\hspace{6pt}name\hspace{6pt}are\hspace{6pt}omitted\hspace{6pt}they\hspace{6pt}will\hspace{6pt}be\hspace{6pt}guessed\hspace{6pt}\\
\hspace{72pt}based\hspace{6pt}on\hspace{6pt}the\hspace{6pt}SOM{\texttt{{'}s\hspace{6pt}parameters}}\\
{\texttt{\hspace{48pt}{'}}}{\texttt{{'}{'}}}\\
\hspace{48pt}{\textbf{if}}\hspace{6pt}self.X\hspace{6pt}==\hspace{6pt}0\hspace{6pt}{\textbf{or}}\hspace{6pt}self.Y\hspace{6pt}==\hspace{6pt}0:\\
\hspace{72pt}self.X\hspace{6pt}=\hspace{6pt}self.Size\\
\hspace{72pt}self.Y\hspace{6pt}=\hspace{6pt}1\\
\hspace{48pt}{\textbf{if}}\hspace{6pt}{\textbf{not}}\hspace{6pt}name:\\
\hspace{72pt}name\hspace{6pt}=\hspace{6pt}{\texttt{{'}\%ds\_\%dd\_\%dr\_\%fa{'}}}\%(self.Size,self.Dims,self.tSteps,{}...\`$\Rightarrow$\\
...{}self.alpha0)\\
\hspace{48pt}codname\hspace{6pt}=\hspace{6pt}path+name+{\texttt{{'}.cod{'}}}\\
\hspace{48pt}mapname\hspace{6pt}=\hspace{6pt}path+name+{\texttt{{'}.map{'}}}\\
\hspace{48pt}{\textbf{if}}\hspace{6pt}self.daMap:\\
\hspace{72pt}mapfile\hspace{6pt}=\hspace{6pt}open(mapname,{\texttt{{'}w{'}}})\\
\hspace{72pt}pickle.dump(self.daMap,mapfile)\\
\hspace{72pt}mapfile.close()\\
\hspace{48pt}outf\hspace{6pt}=\hspace{6pt}open(codname,{\texttt{{'}w{'}}})\\
\hspace{48pt}outf.write({\texttt{\string"\%d\hspace{6pt}\%s\hspace{6pt}\%d\hspace{6pt}\%d\hspace{6pt}gaussian$\backslash$n\string"}}\%(self.Dims,self.Type,self.{}...\`$\Rightarrow$\\
...{}X,self.Y))\\
\hspace{48pt}{\textbf{for}}\hspace{6pt}i\hspace{6pt}{\textbf{in}}\hspace{6pt}xrange(self.Size):\\
\hspace{72pt}outf.write({\texttt{{'}\hspace{6pt}{'}}}.join(str(self.nodes{[}i{]}.tolist()){[}1:\dash{}1{]}.spli{}...\`$\Rightarrow$\\
...{}t({\texttt{{'},\hspace{6pt}{'}}}))+{\texttt{{'}$\backslash$n{'}}})\\
\hspace{48pt}outf.close()\\
\\
\hspace{24pt}{\textbf{def}}\hspace{6pt}randInit(self):\\
\hspace{48pt}{\texttt{{'}{'}}}{\texttt{{'}\hspace{6pt}This\hspace{6pt}function\hspace{6pt}initializes\hspace{6pt}the\hspace{6pt}reference\hspace{6pt}vectors\hspace{6pt}with}}\\
{\texttt{\hspace{72pt}random\hspace{6pt}values\hspace{6pt}in\hspace{6pt}the\hspace{6pt}range\hspace{6pt}of\hspace{6pt}0\hspace{6pt}to\hspace{6pt}1.\hspace{12pt}If\hspace{6pt}your\hspace{6pt}data\hspace{6pt}has}}\\
{\texttt{\hspace{72pt}not\hspace{6pt}standardized\hspace{6pt}within\hspace{6pt}this\hspace{6pt}range,\hspace{6pt}this\hspace{6pt}function\hspace{6pt}should}}\\
{\texttt{\hspace{72pt}be\hspace{6pt}overwritten.}}\\
{\texttt{\hspace{24pt}}}\\
{\texttt{\hspace{72pt}$\ast$\hspace{6pt}Ideally\hspace{6pt}this\hspace{6pt}function\hspace{6pt}would\hspace{6pt}analyze\hspace{6pt}the\hspace{6pt}input\hspace{6pt}data\hspace{6pt}and}}\\
{\texttt{\hspace{84pt}scale\hspace{6pt}the\hspace{6pt}randomization\hspace{6pt}accordingly.\hspace{12pt}SOM\_PAK\hspace{6pt}does\hspace{6pt}}}\\
{\texttt{\hspace{84pt}something\hspace{6pt}along\hspace{6pt}these\hspace{6pt}lines,\hspace{6pt}their\hspace{6pt}code\hspace{6pt}might\hspace{6pt}help\hspace{6pt}find}}\\
{\texttt{\hspace{84pt}a\hspace{6pt}good\hspace{6pt}solution\hspace{6pt}for\hspace{6pt}this.}}\\
{\texttt{\hspace{48pt}{'}}}{\texttt{{'}{'}}}\\
\hspace{48pt}self.nodes\hspace{6pt}=\hspace{6pt}array({[}{[}random.random()\hspace{6pt}{\textbf{for}}\hspace{6pt}j\hspace{6pt}{\textbf{in}}\hspace{6pt}xrange(self.Dims{}...\`$\Rightarrow$\\
...{}){]}\hspace{6pt}{\textbf{for}}\hspace{6pt}i\hspace{6pt}{\textbf{in}}\hspace{6pt}xrange(self.Size){]})\\
\\
\hspace{24pt}{\textbf{def}}\hspace{6pt}findBMU(self,ind,v,ReturnDist\hspace{6pt}=\hspace{6pt}False):\\
\hspace{48pt}{\texttt{{'}{'}}}{\texttt{{'}\hspace{6pt}This\hspace{6pt}function\hspace{6pt}returns\hspace{6pt}the\hspace{6pt}ID\hspace{6pt}of\hspace{6pt}the\hspace{6pt}reference\hspace{6pt}vector\hspace{6pt}that}}\\
{\texttt{\hspace{72pt}is\hspace{6pt}the\hspace{6pt}closest\hspace{6pt}(in\hspace{6pt}Euclidean\hspace{6pt}distance)\hspace{6pt}to\hspace{6pt}input\hspace{6pt}vector\hspace{6pt}v.}}\\
{\texttt{\hspace{72pt}Optionally\hspace{6pt}this\hspace{6pt}function\hspace{6pt}will\hspace{6pt}also\hspace{6pt}return\hspace{6pt}that\hspace{6pt}distance}}\\
{\texttt{\hspace{72pt}between\hspace{6pt}the\hspace{6pt}two.\hspace{12pt}Overwrite\hspace{6pt}this\hspace{6pt}function\hspace{6pt}if\hspace{6pt}you\hspace{6pt}need}}\\
{\texttt{\hspace{72pt}something\hspace{6pt}other\hspace{6pt}than\hspace{6pt}Euclidean\hspace{6pt}dist.}}\\
\\
{\texttt{\hspace{72pt}the\hspace{6pt}{'}}}ind{\texttt{{'}\hspace{6pt}parameter\hspace{6pt}is\hspace{6pt}unused\hspace{6pt}and\hspace{6pt}should\hspace{6pt}be\hspace{6pt}set\hspace{6pt}to\hspace{6pt}None.}}\\
\\
{\texttt{\hspace{72pt}$\ast$\hspace{6pt}As\hspace{6pt}written\hspace{6pt}this\hspace{6pt}function\hspace{6pt}does\hspace{6pt}not\hspace{6pt}handle\hspace{6pt}missing\hspace{6pt}values,}}\\
{\texttt{\hspace{84pt}a\hspace{6pt}previous\hspace{6pt}version\hspace{6pt}did,\hspace{6pt}but\hspace{6pt}it\hspace{6pt}was\hspace{6pt}painfully\hspace{6pt}slow.\hspace{6pt}One}}\\
{\texttt{\hspace{84pt}option\hspace{6pt}would\hspace{6pt}be\hspace{6pt}to\hspace{6pt}remove\hspace{6pt}the\hspace{6pt}distance\hspace{6pt}function\hspace{6pt}and\hspace{6pt}pick}}\\
{\texttt{\hspace{84pt}the\hspace{6pt}appropriate\hspace{6pt}dist\hspace{6pt}function\hspace{6pt}depending\hspace{6pt}on\hspace{6pt}the\hspace{6pt}values}}\\
{\texttt{\hspace{84pt}present.}}\\
{\texttt{\hspace{72pt}$\ast$\hspace{6pt}An\hspace{6pt}external\hspace{6pt}distance\hspace{6pt}function\hspace{6pt}could\hspace{6pt}also\hspace{6pt}be\hspace{6pt}used\hspace{6pt}here,}}\\
{\texttt{\hspace{84pt}however\hspace{6pt}the\hspace{6pt}extra\hspace{6pt}function\hspace{6pt}call\hspace{6pt}will\hspace{6pt}effect}}\\
{\texttt{\hspace{84pt}performance.}}\\
{\texttt{\hspace{48pt}{'}}}{\texttt{{'}{'}}}\\
\hspace{48pt}d\hspace{6pt}=\hspace{6pt}((self.nodes\dash{}v)$\ast$$\ast$2).sum(1)\\
\hspace{48pt}minI\hspace{6pt}=\hspace{6pt}d.argmin()\\
\hspace{48pt}{\textbf{if}}\hspace{6pt}ReturnDist:\\
\hspace{72pt}minD\hspace{6pt}=\hspace{6pt}d{[}minI{]}\\
\hspace{72pt}{\textbf{return}}\hspace{6pt}minI,minD\\
\hspace{48pt}{\textbf{else:}}\\
\hspace{72pt}{\textbf{return}}\hspace{6pt}minI\\
\\
\hspace{24pt}{\textbf{def}}\hspace{6pt}alpha(self,t):\\
\hspace{48pt}{\texttt{{'}{'}}}{\texttt{{'}\hspace{6pt}Returns\hspace{6pt}the\hspace{6pt}learning\hspace{6pt}rate\hspace{6pt}(alpha)\hspace{6pt}as\hspace{6pt}a\hspace{6pt}function\hspace{6pt}of\hspace{6pt}time\hspace{6pt}t.}}\\
{\texttt{\hspace{48pt}{'}}}{\texttt{{'}{'}}}\\
\hspace{48pt}r\hspace{6pt}=\hspace{6pt}self.alpha0\hspace{6pt}$\ast$\hspace{6pt}(1\hspace{6pt}\dash{}\hspace{6pt}(t/float(self.tSteps)))\\
\hspace{48pt}{\textbf{if}}\hspace{6pt}r\hspace{6pt}$<$\hspace{6pt}0:\hspace{6pt}r\hspace{6pt}=\hspace{6pt}0\\
\hspace{48pt}{\textbf{return}}\hspace{6pt}r\\
\hspace{24pt}{\textbf{def}}\hspace{6pt}hci(self,\hspace{6pt}t,\hspace{6pt}dist):\\
\hspace{48pt}{\texttt{{'}{'}}}{\texttt{{'}\hspace{6pt}This\hspace{6pt}kernel\hspace{6pt}function\hspace{6pt}adjust\hspace{6pt}the\hspace{6pt}magnitude\hspace{6pt}with\hspace{6pt}which\hspace{6pt}the}}\\
{\texttt{\hspace{72pt}observation\hspace{6pt}affects\hspace{6pt}the\hspace{6pt}reference\hspace{6pt}vectors.}}\\
{\texttt{\hspace{48pt}{'}}}{\texttt{{'}{'}}}\\
\hspace{48pt}sigma\hspace{6pt}=\hspace{6pt}self.kernelWidth(t)\\
\hspace{48pt}a\hspace{6pt}=\hspace{6pt}self.alpha(t)\\
\hspace{48pt}top\hspace{6pt}=\hspace{6pt}dist$\ast$$\ast$2\\
\hspace{48pt}bottom\hspace{6pt}=\hspace{6pt}(2$\ast$(float(sigma)$\ast$$\ast$2))\\
\hspace{48pt}{\textbf{return}}\hspace{6pt}a\hspace{6pt}$\ast$\hspace{6pt}math.exp(\dash{}top/bottom)\\
\\
\hspace{24pt}{\textbf{def}}\hspace{6pt}merge(self,t,ind,v):\\
\hspace{48pt}{\texttt{{'}{'}}}{\texttt{{'}\hspace{6pt}This\hspace{6pt}function\hspace{6pt}adjusts\hspace{6pt}the\hspace{6pt}actual\hspace{6pt}refernce\hspace{6pt}vectors\hspace{6pt}at\hspace{6pt}time}}\\
{\texttt{\hspace{72pt}{'}}}t{\texttt{{'}\hspace{6pt}based\hspace{6pt}on\hspace{6pt}observation\hspace{6pt}vector\hspace{6pt}{'}}}v{\texttt{{'}.}}\\
{\texttt{\hspace{48pt}{'}}}{\texttt{{'}{'}}}\\
\hspace{48pt}bmu\hspace{6pt}=\hspace{6pt}self.findBMU(None,v)\\
\hspace{48pt}sigma\hspace{6pt}=\hspace{6pt}self.kernelWidth(t)\\
\hspace{48pt}results\hspace{6pt}=\hspace{6pt}self.neighborhood(\hspace{6pt}bmu\hspace{6pt},\hspace{6pt}sigma\hspace{6pt})\\
\hspace{48pt}alteredNodes\hspace{6pt}=\hspace{6pt}{[}(results{[}i{]},self.hci(t,self.odist(i)))\hspace{6pt}{\textbf{for}}\hspace{6pt}i\hspace{6pt}i{}...\`$\Rightarrow$\\
...{}n\hspace{6pt}xrange(len(results)){]}\\
\hspace{48pt}{\textbf{for}}\hspace{6pt}nodeID,hc\hspace{6pt}{\textbf{in}}\hspace{6pt}alteredNodes:\\
\hspace{72pt}{\textbf{if}}\hspace{6pt}len(ind)\hspace{6pt}==\hspace{6pt}self.Dims:\\
\hspace{96pt}part\hspace{6pt}=\hspace{6pt}self.nodes{[}nodeID{]}\\
\hspace{96pt}delta\hspace{6pt}=\hspace{6pt}hc$\ast$(v\dash{}part)\\
\hspace{96pt}self.nodes{[}nodeID{]}\hspace{6pt}=\hspace{6pt}part+delta\\
\hspace{72pt}{\textbf{else:}}\\
\hspace{96pt}part\hspace{6pt}=\hspace{6pt}take(self.nodes{[}nodeID{]},ind)\\
\hspace{96pt}delta\hspace{6pt}=\hspace{6pt}hc$\ast$(v\dash{}part)\\
\hspace{96pt}put(self.nodes{[}nodeID{]},ind,part+delta)\\
\\
\hspace{24pt}{\textbf{def}}\hspace{6pt}run(self,obsf):\\
\hspace{48pt}{\texttt{{'}{'}}}{\texttt{{'}\hspace{6pt}Call\hspace{6pt}this\hspace{6pt}function\hspace{6pt}with\hspace{6pt}your\hspace{6pt}observation\hspace{6pt}file\hspace{6pt}are\hspace{6pt}a}}\\
{\texttt{\hspace{72pt}perameter.}}\\
\\
{\texttt{\hspace{72pt}obsf\hspace{6pt}must\hspace{6pt}be\hspace{6pt}an\hspace{6pt}instance\hspace{6pt}ObsFile\hspace{6pt}as\hspace{6pt}provided\hspace{6pt}by\hspace{6pt}data.py}}\\
\\
{\texttt{\hspace{72pt}All\hspace{6pt}training\hspace{6pt}parameters\hspace{6pt}should\hspace{6pt}be\hspace{6pt}set\hspace{6pt}before\hspace{6pt}calling\hspace{6pt}this}}\\
{\texttt{\hspace{72pt}function.}}\\
{\texttt{\hspace{48pt}{'}}}{\texttt{{'}{'}}}\\
\hspace{48pt}self.neighborhoodCache\hspace{6pt}=\hspace{6pt}\{\}\\
\hspace{48pt}{\textbf{print}}\hspace{6pt}{\texttt{\string"\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\string"}}\\
\hspace{48pt}{\textbf{print}}\hspace{6pt}{\texttt{\string"\#\#\#\hspace{48pt}Configuration\hspace{54pt}\#\#\#\string"}}\\
\hspace{48pt}{\textbf{print}}\hspace{6pt}{\texttt{\string"\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\string"}}\\
\hspace{48pt}{\textbf{print}}\hspace{6pt}{\texttt{\string"\hspace{12pt}N\hspace{6pt}=\hspace{6pt}\%d,\hspace{6pt}maxN\hspace{6pt}=\hspace{6pt}\%f\string"}}\%(self.Size,self.maxN)\\
\hspace{48pt}{\textbf{print}}\hspace{6pt}{\texttt{\string"\hspace{12pt}Total\hspace{6pt}runs:\hspace{6pt}\%d\string"}}\%self.tSteps\\
\hspace{48pt}{\textbf{print}}\hspace{6pt}{\texttt{\string"\hspace{12pt}initial\hspace{6pt}learning\hspace{6pt}rate\hspace{6pt}=\hspace{6pt}\%f\string"}}\%self.alpha0\\
\hspace{48pt}{\textbf{print}}\hspace{6pt}{\texttt{\string"\hspace{12pt}Obs\hspace{6pt}File:\%s\string"}}\%obsf.filename\\
\hspace{48pt}{\textbf{print}}\hspace{6pt}{\texttt{\string"\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\string"}}\\
\hspace{48pt}{\textbf{print}}\hspace{6pt}{\texttt{\string"\#\#\#\hspace{60pt}End\hspace{6pt}Config\hspace{60pt}\#\#\#\string"}}\\
\hspace{48pt}{\textbf{print}}\hspace{6pt}{\texttt{\string"\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\string"}}\\
\hspace{48pt}{\textbf{print}}\hspace{6pt}{\texttt{\string"\string"}}\\
\hspace{48pt}{\textbf{print}}\hspace{6pt}{\texttt{\string"Running...\string"}}\\
\hspace{48pt}t1\hspace{6pt}=\hspace{6pt}time.time()\\
\hspace{48pt}T\hspace{6pt}=\hspace{6pt}self.tSteps\\
\hspace{48pt}{\textbf{for}}\hspace{6pt}t\hspace{6pt}{\textbf{in}}\hspace{6pt}xrange(self.tSteps):\\
\hspace{72pt}id,ind,v\hspace{6pt}=\hspace{6pt}obsf.stream()\\
\hspace{72pt}self.merge(t,ind,v)\\
\hspace{72pt}sys.stdout.write({\texttt{\string"$\backslash$r\%.2f\%\%\string"}}\%(100$\ast$float(t)/T))\\
\hspace{72pt}sys.stdout.flush()\\
\hspace{48pt}{\textbf{print}}\hspace{6pt}{\texttt{\string"$\backslash$nRun\hspace{6pt}compleated\hspace{6pt}in\hspace{6pt}\%f\hspace{6pt}seconds\string"}}\%(time.time()\dash{}t1)\\
\\
\hspace{24pt}{\textbf{def}}\hspace{6pt}map(self,obsf):\\
\hspace{48pt}{\texttt{{'}{'}}}{\texttt{{'}\hspace{6pt}This\hspace{6pt}function\hspace{6pt}maps\hspace{6pt}the\hspace{6pt}observation\hspace{6pt}back\hspace{6pt}onto\hspace{6pt}the\hspace{6pt}trained}}\\
{\texttt{\hspace{72pt}SOM.\hspace{12pt}The\hspace{6pt}QError\hspace{6pt}is\hspace{6pt}returned.}}\\
{\texttt{\hspace{48pt}{'}}}{\texttt{{'}{'}}}\\
\hspace{48pt}qerror\hspace{6pt}=\hspace{6pt}0\\
\hspace{48pt}counter\hspace{6pt}=\hspace{6pt}0\hspace{6pt}\\
\hspace{48pt}daMap\hspace{6pt}=\hspace{6pt}\{\}\hspace{6pt}{\it{\#\hspace{6pt}keys\hspace{6pt}are\hspace{6pt}node\hspace{6pt}ID{'}s,\hspace{6pt}values\hspace{6pt}are\hspace{6pt}lists\hspace{6pt}of\hspace{6pt}observati}}{}...\`$\Rightarrow$\\
...{}{\it{on\hspace{6pt}ID{'}s.}}\\
\hspace{48pt}{\textbf{for}}\hspace{6pt}id,dimIds,obs\hspace{6pt}{\textbf{in}}\hspace{6pt}obsf:\\
\hspace{72pt}bm,err\hspace{6pt}=\hspace{6pt}self.findBMU(dimIds,obs,ReturnDist=True)\\
\hspace{72pt}qerror\hspace{6pt}+=\hspace{6pt}err\\
\hspace{72pt}{\textbf{if}}\hspace{6pt}{\textbf{not}}\hspace{6pt}bm\hspace{6pt}{\textbf{in}}\hspace{6pt}daMap:\\
\hspace{96pt}daMap{[}bm{]}\hspace{6pt}=\hspace{6pt}{[}{]}\\
\hspace{72pt}daMap{[}bm{]}.append(id)\\
\hspace{72pt}sys.stdout.write({\texttt{\string".\%d,\%f.$\backslash$r\string"}}\%(counter,err))\\
\hspace{72pt}sys.stdout.flush()\\
\hspace{72pt}counter\hspace{6pt}+=\hspace{6pt}1\\
\hspace{48pt}{\textbf{print}}\hspace{6pt}{\texttt{\string"\string"}}\\
\hspace{48pt}qerror\hspace{6pt}=\hspace{6pt}qerror/counter\\
\hspace{48pt}self.daMap\hspace{6pt}=\hspace{6pt}daMap\\
\hspace{48pt}{\textbf{return}}\hspace{6pt}qerror\\
\hspace{24pt}\\
{\textbf{class}}\hspace{6pt}GraphTopology(som):\\
\hspace{24pt}{\texttt{{'}{'}}}{\texttt{{'}\hspace{6pt}GraphTopology\hspace{6pt}extends\hspace{6pt}\string"som\string"\hspace{6pt}and\hspace{6pt}provides\hspace{6pt}a\hspace{6pt}functioning}}\\
{\texttt{\hspace{48pt}implementation\hspace{6pt}of\hspace{6pt}the\hspace{6pt}Self\dash{}Organizing\hspace{6pt}Map\hspace{6pt}training\hspace{6pt}algorithm.}}\\
{\texttt{\hspace{48pt}The\hspace{6pt}topology\hspace{6pt}is\hspace{6pt}based\hspace{6pt}on\hspace{6pt}a\hspace{6pt}graph\hspace{6pt}structure\hspace{6pt}with\hspace{6pt}is\hspace{6pt}provided}}\\
{\texttt{\hspace{48pt}using\hspace{6pt}the\hspace{6pt}NetworkX\hspace{6pt}graph\hspace{6pt}library.}}\\
{\texttt{\hspace{24pt}{'}}}{\texttt{{'}{'}}}\\
\hspace{24pt}{\textbf{def}}\hspace{6pt}\_\_init\_\_(self,G=None,Type={\texttt{{'}Graph{'}}}):\\
\hspace{48pt}{\texttt{{'}{'}}}{\texttt{{'}\hspace{6pt}Special\hspace{6pt}initializtion\hspace{6pt}for\hspace{6pt}this\hspace{6pt}topology,}}\\
{\texttt{\hspace{72pt}also\hspace{6pt}calls\hspace{6pt}som.\_\_init\_\_}}\\
{\texttt{\hspace{48pt}{'}}}{\texttt{{'}{'}}}\\
\hspace{48pt}som.\_\_init\_\_(self)\\
\hspace{48pt}self.Type\hspace{6pt}=\hspace{6pt}Type\\
\hspace{48pt}{\textbf{if}}\hspace{6pt}G:\\
\hspace{72pt}self.G\hspace{6pt}=\hspace{6pt}G\\
\\
\hspace{72pt}{\it{\#\hspace{6pt}Number\hspace{6pt}of\hspace{6pt}nodes\hspace{6pt}(neurons)\hspace{6pt}in\hspace{6pt}the\hspace{6pt}network.}}\\
\hspace{72pt}self.Size\hspace{6pt}=\hspace{6pt}G.order()\\
\hspace{72pt}{\it{\#\hspace{6pt}if\hspace{6pt}findWidth\hspace{6pt}is\hspace{6pt}not\hspace{6pt}given\hspace{6pt}a\hspace{6pt}seed\hspace{6pt}it\hspace{6pt}will\hspace{6pt}brute\hspace{6pt}force\hspace{6pt}the}}\\
\hspace{72pt}{\it{\#\hspace{6pt}total\hspace{6pt}network\hspace{6pt}width,\hspace{6pt}this\hspace{6pt}could\hspace{6pt}take\hspace{6pt}a\hspace{6pt}long\hspace{6pt}time.\hspace{6pt}For}}\\
\hspace{72pt}{\it{\#\hspace{6pt}the\hspace{6pt}spherical\hspace{6pt}network,\hspace{6pt}one\hspace{6pt}of\hspace{6pt}the\hspace{6pt}polls\hspace{6pt}should\hspace{6pt}yield\hspace{6pt}the}}\\
\hspace{72pt}{\it{\#\hspace{6pt}correct\hspace{6pt}width.\hspace{6pt}Or\hspace{6pt}possibly\hspace{6pt}the\hspace{6pt}node\hspace{6pt}with\hspace{6pt}lowest\hspace{6pt}degree.}}\\
\hspace{72pt}{\it{\#\hspace{6pt}The\hspace{6pt}Width\hspace{6pt}messures\hspace{6pt}the\hspace{6pt}largest\hspace{6pt}distance\hspace{6pt}between\hspace{6pt}any\hspace{6pt}two}}\\
\hspace{72pt}{\it{\#\hspace{6pt}nodes\hspace{6pt}in\hspace{6pt}the\hspace{6pt}network.}}\\
\\
\hspace{72pt}self.Width\hspace{6pt}=\hspace{6pt}nf.findWidth(G,G.nodes(){[}\dash{}1{]})\hspace{6pt}\\
\\
\hspace{24pt}{\textbf{def}}\hspace{6pt}save(self,path,name):\\
\hspace{48pt}{\texttt{{'}{'}}}{\texttt{{'}\hspace{6pt}in\hspace{6pt}addition\hspace{6pt}to\hspace{6pt}saving\hspace{6pt}this\hspace{6pt}codebook,\hspace{6pt}we\hspace{6pt}also\hspace{6pt}need\hspace{6pt}to\hspace{6pt}save}}\\
{\texttt{\hspace{72pt}the\hspace{6pt}graph}}\\
{\texttt{\hspace{48pt}{'}}}{\texttt{{'}{'}}}\\
\hspace{48pt}som.save(self,path,name)\\
\hspace{48pt}{\textbf{if}}\hspace{6pt}{\textbf{not}}\hspace{6pt}name:\\
\hspace{72pt}name\hspace{6pt}=\hspace{6pt}{\texttt{{'}\%ds\_\%dd\_\%dr\_\%fa{'}}}\%(self.Size,self.Dims,self.tSteps,{}...\`$\Rightarrow$\\
...{}self.alpha0)\\
\hspace{48pt}graphFile\hspace{6pt}=\hspace{6pt}path+name+{\texttt{{'}.graph{'}}}\\
\hspace{48pt}f\hspace{6pt}=\hspace{6pt}open(graphFile,{\texttt{{'}wb{'}}})\\
\hspace{48pt}pickle.dump(self.G,f)\hspace{6pt}{\it{\#serialize\hspace{6pt}the\hspace{6pt}graph\hspace{6pt}to\hspace{6pt}a\hspace{6pt}textfile.}}\\
\hspace{48pt}f.close()\\
\hspace{24pt}{\textbf{def}}\hspace{6pt}load(self,path,name):\\
\hspace{48pt}{\texttt{{'}{'}}}{\texttt{{'}\hspace{6pt}loads\hspace{6pt}the\hspace{6pt}graph\hspace{6pt}and\hspace{6pt}other\hspace{6pt}information\hspace{6pt}from\hspace{6pt}disk\hspace{6pt}{'}}}{\texttt{{'}{'}}}\\
\hspace{48pt}som.load(self,path,name)\\
\hspace{48pt}{\textbf{if}}\hspace{6pt}{\textbf{not}}\hspace{6pt}name:\\
\hspace{72pt}name\hspace{6pt}=\hspace{6pt}{\texttt{{'}\%ds\_\%dd\_\%dr\_\%fa{'}}}\%(self.Size,self.Dims,self.tSteps,{}...\`$\Rightarrow$\\
...{}self.alpha0)\\
\hspace{48pt}graphFile\hspace{6pt}=\hspace{6pt}path+name+{\texttt{{'}.graph{'}}}\\
\hspace{48pt}{\textbf{if}}\hspace{6pt}os.path.exists(graphFile):\\
\hspace{72pt}f\hspace{6pt}=\hspace{6pt}open(graphFile,{\texttt{{'}rb{'}}})\\
\hspace{72pt}self.G\hspace{6pt}=\hspace{6pt}G\hspace{6pt}=\hspace{6pt}pickle.load(f)\\
\hspace{72pt}self.Size\hspace{6pt}=\hspace{6pt}G.order()\\
\hspace{72pt}self.Width\hspace{6pt}=\hspace{6pt}nf.findWidth(G,G.nodes(){[}\dash{}1{]})\hspace{6pt}\\
\hspace{72pt}f.close()\\
\hspace{24pt}{\textbf{def}}\hspace{6pt}kernelWidth(self,t):\\
\hspace{48pt}{\texttt{{'}{'}}}{\texttt{{'}\hspace{6pt}kernelWidth\hspace{6pt}returns\hspace{6pt}the\hspace{6pt}width\hspace{6pt}of\hspace{6pt}the\hspace{6pt}neighborhood\hspace{6pt}in\hspace{6pt}terms}}\\
{\texttt{\hspace{72pt}of\hspace{6pt}order.}}\\
{\texttt{\hspace{48pt}{'}}}{\texttt{{'}{'}}}\\
\hspace{48pt}r\hspace{6pt}=\hspace{6pt}round((self.Width$\ast$self.maxN)\hspace{6pt}$\ast$\hspace{6pt}(1\hspace{6pt}\dash{}\hspace{6pt}(t/float(self.tSteps)){}...\`$\Rightarrow$\\
...{}))\\
\hspace{48pt}r\hspace{6pt}=\hspace{6pt}int(r)\\
\hspace{48pt}{\textbf{if}}\hspace{6pt}r\hspace{6pt}==\hspace{6pt}0:\hspace{6pt}r\hspace{6pt}=\hspace{6pt}1\\
\hspace{48pt}{\textbf{return}}\hspace{6pt}r\\
\hspace{24pt}{\textbf{def}}\hspace{6pt}neighborhood(self,bmu,kernelWidth):\\
\hspace{48pt}{\texttt{{'}{'}}}{\texttt{{'}}}\\
{\texttt{\hspace{48pt}This\hspace{6pt}function\hspace{6pt}returns\hspace{6pt}a\hspace{6pt}dictionary\hspace{6pt}containing\hspace{6pt}the\hspace{6pt}neighbors\hspace{6pt}of}}\\
{\texttt{\hspace{48pt}bmu\hspace{6pt}as\hspace{6pt}keys\hspace{6pt}and\hspace{6pt}their\hspace{6pt}dist\hspace{6pt}(as\hspace{6pt}an\hspace{6pt}order)\hspace{6pt}as\hspace{6pt}values.}}\\
{\texttt{\hspace{48pt}{'}}}{\texttt{{'}{'}}}\\
\hspace{48pt}{\textbf{return}}\hspace{6pt}nf.neighborhood(self.G,bmu,kernelWidth)\\
\hspace{24pt}{\textbf{def}}\hspace{6pt}merge(self,t,ind,v):\\
\hspace{48pt}{\texttt{{'}{'}}}{\texttt{{'}\hspace{6pt}This\hspace{6pt}function\hspace{6pt}adjusts\hspace{6pt}the\hspace{6pt}actual\hspace{6pt}refernce\hspace{6pt}vectors\hspace{6pt}at\hspace{6pt}time}}\\
{\texttt{\hspace{72pt}{'}}}t{\texttt{{'}\hspace{6pt}based\hspace{6pt}on\hspace{6pt}observation\hspace{6pt}vector\hspace{6pt}{'}}}v{\texttt{{'}.}}\\
{\texttt{\hspace{48pt}{'}}}{\texttt{{'}{'}}}\\
\hspace{48pt}bmu\hspace{6pt}=\hspace{6pt}self.findBMU(None,v)\\
\hspace{48pt}a\hspace{6pt}=\hspace{6pt}self.alpha(t)\\
\hspace{48pt}sigma\hspace{6pt}=\hspace{6pt}self.kernelWidth(t)\\
\hspace{48pt}results\hspace{6pt}=\hspace{6pt}self.neighborhood(\hspace{6pt}bmu\hspace{6pt},\hspace{6pt}sigma\hspace{6pt})\\
\hspace{48pt}sigma\hspace{6pt}=\hspace{6pt}float(sigma)\\
\\
\hspace{48pt}{\it{\#\hspace{6pt}hci\hspace{6pt}has\hspace{6pt}been\hspace{6pt}internalized\hspace{6pt}in\hspace{6pt}this\hspace{6pt}next\hspace{6pt}line,}}\\
\hspace{48pt}{\it{\#\hspace{6pt}to\hspace{6pt}speed\hspace{6pt}up\hspace{6pt}processing}}\\
\hspace{48pt}alteredNodes\hspace{6pt}=\hspace{6pt}{[}(node,(v\dash{}self.nodes{[}node{]})$\ast$(a$\ast$math.exp(\dash{}(odist{}...\`$\Rightarrow$\\
...{}$\ast$odist)/(2$\ast$sigma$\ast$sigma))))\hspace{6pt}{\textbf{for}}\hspace{6pt}node,odist\hspace{6pt}{\textbf{in}}\hspace{6pt}results.iteritems(){]}\\
\hspace{48pt}{\textbf{for}}\hspace{6pt}nodeID,node\hspace{6pt}{\textbf{in}}\hspace{6pt}alteredNodes:\\
\hspace{72pt}self.nodes{[}nodeID{]}\hspace{6pt}+=\hspace{6pt}node\\
\\
{\it{\#class\hspace{6pt}Topology(som):}}\\
{\it{\#\hspace{24pt}\string"\string"\string"\hspace{6pt}Template\hspace{6pt}class\hspace{6pt}for\hspace{6pt}topology.}}\\
{\it{\#\hspace{48pt}Copy\hspace{6pt}this\hspace{6pt}class\hspace{6pt}to\hspace{6pt}create\hspace{6pt}a\hspace{6pt}new\hspace{6pt}topology\hspace{6pt}for\hspace{6pt}som.}}\\
{\it{\#\hspace{24pt}\string"\string"\string"}}\\
{\it{\#\hspace{24pt}def\hspace{6pt}\_\_init\_\_(self):}}\\
{\it{\#\hspace{42pt}som.\_\_init\_\_(self)}}\\
{\it{\#\hspace{24pt}def\hspace{6pt}save(self,path,name):}}\\
{\it{\#\hspace{42pt}som.save(self,path,name)}}\\
{\it{\#\hspace{24pt}def\hspace{6pt}load(self,path,name):}}\\
{\it{\#\hspace{42pt}som.load(self,path,name)}}\\
{\it{\#\hspace{24pt}def\hspace{6pt}randInit(self):}}\\
{\it{\#\hspace{42pt}som.randInit(self)}}\\
{\it{\#\hspace{24pt}def\hspace{6pt}kernelWidth(self,t):}}\\
{\it{\#\hspace{42pt}{'}{'}{'}\hspace{6pt}kernelWidth\hspace{6pt}returns\hspace{6pt}the\hspace{6pt}width\hspace{6pt}of\hspace{6pt}the\hspace{6pt}neighborhood\hspace{6pt}in\hspace{6pt}terms}}\\
{\it{\#\hspace{66pt}of\hspace{6pt}order.}}\\
{\it{\#\hspace{42pt}{'}{'}{'}}}\\
{\it{\#\hspace{42pt}pass}}\\
{\it{\#\hspace{24pt}def\hspace{6pt}odist(n):}}\\
{\it{\#\hspace{42pt}\string"\string"\string"}}\\
{\it{\#\hspace{42pt}n\hspace{6pt}is\hspace{6pt}the\hspace{6pt}nth\hspace{6pt}neuron\hspace{6pt}in\hspace{6pt}the\hspace{6pt}in\hspace{6pt}neighborhood,\hspace{6pt}return{'}s\hspace{6pt}order}}\\
{\it{\#\hspace{42pt}example\hspace{6pt}the\hspace{6pt}3rd\hspace{6pt}neuron\hspace{6pt}in\hspace{6pt}the\hspace{6pt}set\hspace{6pt}is\hspace{6pt}1\hspace{6pt}order\hspace{6pt}from\hspace{6pt}the\hspace{6pt}0th.}}\\
{\it{\#\hspace{42pt}\string"\string"\string"}}\\
{\it{\#\hspace{42pt}pass}}\\
{\it{\#\hspace{24pt}def\hspace{6pt}neighborhood(self,bmu,kernelWidth):}}\\
{\it{\#\hspace{42pt}{'}{'}{'}}}\\
{\it{\#\hspace{42pt}This\hspace{6pt}function\hspace{6pt}returns\hspace{6pt}a\hspace{6pt}dictionary\hspace{6pt}containing\hspace{6pt}the\hspace{6pt}neighbors\hspace{6pt}of}}\\
{\it{\#\hspace{42pt}bmu\hspace{6pt}as\hspace{6pt}keys\hspace{6pt}and\hspace{6pt}their\hspace{6pt}dist\hspace{6pt}(as\hspace{6pt}an\hspace{6pt}order)\hspace{6pt}as\hspace{6pt}values.}}\\
{\it{\#\hspace{42pt}{'}{'}{'}}}\\
{\it{\#\hspace{42pt}pass}}
\end{tabbing}}}
